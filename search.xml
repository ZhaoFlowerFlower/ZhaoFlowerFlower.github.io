<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022.3.12碎碎念</title>
    <url>/2022/03/12/2022-3-12%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="愁"><a href="#愁" class="headerlink" title="愁"></a>愁</h1><h2 id="丑奴儿·书博山道中壁"><a href="#丑奴儿·书博山道中壁" class="headerlink" title="丑奴儿·书博山道中壁"></a>丑奴儿·书博山道中壁</h2><h3 id="辛弃疾"><a href="#辛弃疾" class="headerlink" title="辛弃疾"></a>辛弃疾</h3><p>少年不识愁滋味，爱上层楼。爱上层楼，为赋新词强说愁。<br>而今识尽愁滋味，欲说还休。欲说还休，却道天凉好个秋。</p>
]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>2022Java期末复习</title>
    <url>/2022/05/12/2022Java%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="时不我待，做想做的事，见想见的人"><a href="#时不我待，做想做的事，见想见的人" class="headerlink" title="时不我待，做想做的事，见想见的人"></a>时不我待，做想做的事，见想见的人</h2><hr>
<p>第五题是IO实验内容，较容易，略。</p>
<hr>
<h2 id="ONE"><a href="#ONE" class="headerlink" title="ONE"></a>ONE</h2><p>假设已经封装好Book,请根据要求实现对应的方法<br>public class Book {<br> private String bookname;//书名<br> private String author;//作者<br> private String publish;//出版社<br> private double price;//价格<br> private int print;//版次<br> private int  count;//印数<br> private String time; //出版时间<br>//省略所有的getter及setter<br>}<br>（1）传入一个Book对象的List集合以及作者名，返回一个包含该作者出版的所有图书名字的List集合<br>（2）传入一个Book对象的List集合，返回一个按书定价从小到大排序的书的名字的集合。<br>（3）传入一个Book对象的List集合，返回一个按出版社分组的Map，Map的key为出版社，value为该出版社的图书集合。<br><em><strong>代码请点击“阅读全文”</strong></em></p>
<span id="more"></span>
<p>Book类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">	private String bookname;//书名</span><br><span class="line">	private String author;//作者</span><br><span class="line">	private  String publish;//出版社</span><br><span class="line">	private double price;//价格</span><br><span class="line">	private int print;//版次</span><br><span class="line">	private int  count;//印数 </span><br><span class="line">	private String time; //出版时间</span><br><span class="line">	public Book(String string, String string2, String string3, double d, int i, int j, String string4) &#123;</span><br><span class="line">		// TODO Auto-generated constructor stub</span><br><span class="line">		this.bookname=string;</span><br><span class="line">		this.author=string2;</span><br><span class="line">		this.publish=string3;</span><br><span class="line">		this.price=d;</span><br><span class="line">		this.print=i;</span><br><span class="line">		this.count=j;</span><br><span class="line">		this.time=string4;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getBookname() &#123;</span><br><span class="line">		return bookname;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setBookname(String bookname) &#123;</span><br><span class="line">		this.bookname = bookname;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getAuthor() &#123;</span><br><span class="line">		return author;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setAuthor(String author) &#123;</span><br><span class="line">		this.author = author;</span><br><span class="line">	&#125;</span><br><span class="line">	public  String getPublish() &#123;</span><br><span class="line">		return publish;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setPublish(String publish) &#123;</span><br><span class="line">		this.publish = publish;</span><br><span class="line">	&#125;</span><br><span class="line">	public Double getPrice() &#123;</span><br><span class="line">		return price;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setPrice(double price) &#123;</span><br><span class="line">		this.price = price;</span><br><span class="line">	&#125;</span><br><span class="line">	public int getPrint() &#123;</span><br><span class="line">		return print;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setPrint(int print) &#123;</span><br><span class="line">		this.print = print;</span><br><span class="line">	&#125;</span><br><span class="line">	public int getCount() &#123;</span><br><span class="line">		return count;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setCount(int count) &#123;</span><br><span class="line">		this.count = count;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getTime() &#123;</span><br><span class="line">		return time;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setTime(String time) &#123;</span><br><span class="line">		this.time = time;</span><br><span class="line">	&#125;</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;Book [bookname=&quot;+bookname+&quot;,author=&quot;+author+&quot;,&quot;</span><br><span class="line">				+ &quot;publish=&quot;+publish+&quot;,price=&quot;+price+&quot;,print=&quot;+price+&quot;,&quot;</span><br><span class="line">						+ &quot;print=&quot;+print+&quot;,count=&quot;+count+&quot;,time=&quot;+time+&quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">public class One &#123;</span><br><span class="line">	</span><br><span class="line">	public static List&lt;String&gt; first(List &lt;Book&gt; l,String au)&#123;</span><br><span class="line">		List &lt;String&gt; m=new ArrayList&lt;String&gt;();</span><br><span class="line">		for(Book s:l) &#123;</span><br><span class="line">			if(s.getAuthor()==au)</span><br><span class="line">				m.add(s.getBookname());</span><br><span class="line">		&#125;</span><br><span class="line">		for (String s : m) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">		return m;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static List&lt;String&gt; second(List &lt;Book&gt; l)&#123;</span><br><span class="line">		List &lt;String&gt; k=new ArrayList&lt;String&gt;();;</span><br><span class="line">		l.sort((a,b)-&gt;a.getPrice().compareTo(b.getPrice()));</span><br><span class="line">		for(Book s:l) &#123;</span><br><span class="line">				k.add(s.getBookname());</span><br><span class="line">		&#125;</span><br><span class="line">		for (String s : k) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">		return k;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static Map&lt;String,List &lt;Book&gt;&gt; third(List &lt;Book&gt; l)&#123;</span><br><span class="line">		Map&lt;String, List&lt;Book&gt;&gt; map=l.stream()</span><br><span class="line">				.collect(Collectors.groupingBy(Book::getPublish));</span><br><span class="line">		for(Book s : map.get(&quot;土豆出版社&quot;))&#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">		return map;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// new5个图书对象</span><br><span class="line">		Book b1 = new Book(&quot;斗破苍穹&quot;,&quot;天蚕土豆&quot;,&quot;土豆出版社&quot;,55.8, 1 , 16 , &quot;2001&quot; );</span><br><span class="line">		Book b2 = new Book( &quot;武动乾坤&quot;,&quot;天蚕土豆&quot;,&quot;土豆出版社&quot;, 49.9,2,16,&quot;2002&quot;);</span><br><span class="line">		Book b3 = new Book(&quot;战皇&quot;,&quot;傲天无痕&quot;,&quot;无痕出版社&quot;,55,3,16,&quot;2003&quot; );</span><br><span class="line">		Book b4 = new Book(&quot;武逆&quot;,&quot;只是小虾米&quot;,&quot;虾米出版社&quot; ,48.5,4,16,&quot;2004&quot; );</span><br><span class="line">		Book b5 = new Book(&quot;绝世武神&quot;,&quot;净无痕&quot;, &quot;无痕出版社&quot; ,55.8,5,16,&quot;2005&quot;);</span><br><span class="line">		Book b6 = new Book(&quot;武极天下&quot;,&quot;蚕茧里的牛&quot;, &quot;蚕茧出版社&quot;,53.6,6,16,&quot;2006&quot; );</span><br><span class="line">		</span><br><span class="line">		List&lt;Book&gt; l = new ArrayList&lt;Book&gt;();</span><br><span class="line">		l.add(b1);</span><br><span class="line">		l.add(b2);</span><br><span class="line">		l.add(b3);</span><br><span class="line">		l.add(b4);</span><br><span class="line">		l.add(b5);</span><br><span class="line">		l.add(b6);</span><br><span class="line">		for (Book s : l) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;======================================================&quot;);</span><br><span class="line">		</span><br><span class="line">		//第一题</span><br><span class="line">		/*List &lt;String&gt; n=new ArrayList&lt;String&gt;();</span><br><span class="line">		n=first(l,&quot;天蚕土豆&quot;);</span><br><span class="line">		for (String s : n) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;*/</span><br><span class="line">		</span><br><span class="line">		//第二题</span><br><span class="line">		/*List &lt;String&gt; gg=new ArrayList&lt;String&gt;();</span><br><span class="line">		gg=second(l);</span><br><span class="line">		System.out.println(&quot;======================================================&quot;);</span><br><span class="line">		for (String s : gg) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;*/</span><br><span class="line">		</span><br><span class="line">        //第三题</span><br><span class="line">		/*Map&lt;String, List&lt;Book&gt;&gt; map=new HashMap&lt;String, List&lt;Book&gt;&gt;();</span><br><span class="line">		map=third(l);*/</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="TWO"><a href="#TWO" class="headerlink" title="TWO"></a>TWO</h2><p>苹果有不同的种类，而不同的品牌会同生产同一种苹果，苹果、种类和品牌三者可以构成一种嵌套关系。<br>//品牌<br>public class Brand {<br> private String brandName;<br> //省略brandName的getter/setter方法<br>}<br>//种类<br>public class Kind {<br> private Brand brand;<br> // 省略brand的getter/setter方法<br>}<br>//苹果<br>public class Apple {<br> private Kind kind;<br> // 省略kind的getter/setter方法<br>}<br>假设我想得到某个苹果的品牌信息，怎么办？请帮我完成下面的方法：<br>public static String getAppleBrandName(Apple apple) {<br>//……<br>}<br>要求<br> (1)不能出现NullPointerException<br> (2)不能用if语句判断</p>
<p>Apple类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Optional;</span><br><span class="line"></span><br><span class="line">public class Apple &#123;</span><br><span class="line">	 </span><br><span class="line">	private Kind kind2;</span><br><span class="line"> </span><br><span class="line">	public Optional&lt;Kind&gt; getKind2() &#123;   // 使用Optional封装返回值</span><br><span class="line">		return Optional.ofNullable(kind2);</span><br><span class="line">	&#125;</span><br><span class="line">	public void setKind2(Kind kind2) &#123;</span><br><span class="line">		this.kind2 = kind2;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;Apple2 [kind2=&quot; + kind2 + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Brand类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Brand &#123;</span><br><span class="line">	</span><br><span class="line">	private String brandName;</span><br><span class="line"> </span><br><span class="line">	public String getBrandName() &#123;</span><br><span class="line">		return brandName;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setBrandName(String brandName) &#123;</span><br><span class="line">		this.brandName = brandName;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;Brand [brandName=&quot; + brandName + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Kind类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Optional;</span><br><span class="line"></span><br><span class="line">public class Kind &#123;</span><br><span class="line">	</span><br><span class="line">	private Brand brand;</span><br><span class="line"> </span><br><span class="line">	public Optional&lt;Brand&gt; getBrand() &#123;   // 使用Optional封装返回值</span><br><span class="line">		return Optional.ofNullable(brand);</span><br><span class="line">	&#125;</span><br><span class="line">	public void setBrand(Brand brand) &#123;</span><br><span class="line">		this.brand = brand;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;Kind2 [brand=&quot; + brand + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Optional;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		System.out.println(getAppleBrand(null));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private static String getAppleBrand(Apple apple) &#123;</span><br><span class="line">		return Optional.ofNullable(apple)</span><br><span class="line">				.flatMap(Apple::getKind2)</span><br><span class="line">				.flatMap(Kind::getBrand)</span><br><span class="line">				.map(Brand::getBrandName)</span><br><span class="line">				.orElse(&quot;empty&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="THREE"><a href="#THREE" class="headerlink" title="THREE"></a>THREE</h2><p>编写一个方法，传入一个登记人数，输出登记人数，一旦传入参数为负数，且抛出自定义的异常。<br>//（1）自定义异常类MyException<br>public class Test{<br>        public void regist(int num) throws MyException {<br>        //（2）按题目要求完成方法体<br>        }<br>        public void manager() {<br>        //(3)调用regist(int num)完成登记，如果参数为负，显示“人数为负值，不合理”的提示信息<br> System.out.print(“本次登记操作结束”);<br>       }<br>       public static void main(String args[]){<br>            Test t = new Test();<br>            t.manager();<br>       }<br>}</p>
<p>自定义异常类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SuppressWarnings(&quot;serial&quot;)</span><br><span class="line">public class MyException extends Exception&#123; //创建自定义异常</span><br><span class="line">    public MyException(String ErrorExceptin)&#123; //构造方法</span><br><span class="line">        super(ErrorExceptin); //父类构造方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">//（1）自定义异常类MyException  </span><br><span class="line">public class TestException &#123;</span><br><span class="line">	        public void regist(int num) throws MyException &#123;</span><br><span class="line">	        	//（2）按题目要求完成方法体</span><br><span class="line">	        	if(num&lt;0) &#123;</span><br><span class="line">	        		throw new MyException(&quot;人数为负值，不合理&quot;);</span><br><span class="line">	        	&#125;</span><br><span class="line">	        	else &#123;</span><br><span class="line">	        		System.out.println(&quot;此次登记人数为：&quot;+num);</span><br><span class="line">	        	&#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	        public void manager() &#123;</span><br><span class="line">	        	//(3)调用regist(int num)完成登记，如果参数为负，显示“人数为负值，不合理”的提示信息</span><br><span class="line">	        	</span><br><span class="line">	        	try &#123;</span><br><span class="line">	        		while(true)</span><br><span class="line">	        		&#123;</span><br><span class="line">	        			Scanner input=new Scanner(System.in);</span><br><span class="line">	        		regist(input.nextInt());</span><br><span class="line">	        		&#125;</span><br><span class="line">	        		</span><br><span class="line">	        	&#125;catch(MyException e) &#123;</span><br><span class="line">	        		</span><br><span class="line">	        		System.out.println(e);</span><br><span class="line">	        	&#125;finally&#123;</span><br><span class="line">	        		System.out.print(&quot;本次登记操作结束&quot;);</span><br><span class="line">	        	&#125;</span><br><span class="line">	       &#125;</span><br><span class="line">	       public static void main(String args[])&#123;</span><br><span class="line">	    	   TestException t = new TestException();</span><br><span class="line">	    	   t.manager();</span><br><span class="line">	       &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="FOUR"><a href="#FOUR" class="headerlink" title="FOUR"></a>FOUR</h2><p>AB两个人拥有同一个账户，两个人同时从这个账户取钱，假设账户已有钱数是10000元,A从柜台进行取钱，一次取300元,取后输出“A在柜台进行取钱，取了300元！目前账户还有XXX元”；B从ATM机进行取钱，一次取200元，取后输出“B从ATM机进行取钱，取了200元！目前账户还有XXX元”，直到账户钱数不足两人要取的数时，就不能取了，输出“余额不足。”，其中XXX是账户的余额数。</p>
<p>编程用个线程模拟AB两个人的取钱过程，要求<br>（1）两个人都有取钱的过程；<br>（2）不能出现钱数不一致的问题。</p>
<p>简单的线程同步互斥问题。</p>
<p>银行类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Objects;</span><br><span class="line"></span><br><span class="line">public class Bank &#123;</span><br><span class="line">	// 假设一个账户有1000块钱  </span><br><span class="line">	static double money = 10000;</span><br><span class="line">	// 柜台Counter取钱的方法  </span><br><span class="line">	private void Counter(double money) &#123;</span><br><span class="line">		Bank.money -= money;</span><br><span class="line">		System.out.println(&quot;A在柜台取钱&quot; + money + &quot;元，还剩&quot; + Bank.money + &quot;元！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	// ATM取钱的方法  </span><br><span class="line">	private void ATM(double money) &#123;</span><br><span class="line">		Bank.money -= money;</span><br><span class="line">		System.out.println(&quot;B在ATM取钱&quot; + money + &quot;元，还剩&quot; + Bank.money + &quot;元！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//提供一个对外取款途径，防止直接调取方法同时取款时，并发余额显示错误</span><br><span class="line">	public synchronized void outMoney(double money, String mode) throws Exception&#123;</span><br><span class="line">		if(money &gt; Bank.money)&#123;</span><br><span class="line">			//校验余额是否充足</span><br><span class="line">			throw new Exception(&quot;取款金额&quot;+money+&quot;,余额只剩&quot;+Bank.money+&quot;，取款失败&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		if(Objects.equals(mode, &quot;ATM&quot;))&#123;</span><br><span class="line">			ATM(money);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			Counter(money);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PersonA类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PersonA extends Thread &#123;</span><br><span class="line">	 </span><br><span class="line">	Bank bank;</span><br><span class="line">	</span><br><span class="line">	String mode;</span><br><span class="line"> </span><br><span class="line">	public PersonA(Bank bank, String mode) &#123;</span><br><span class="line">		this.mode = mode;</span><br><span class="line">		this.bank = bank;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	public void run ()&#123;</span><br><span class="line">		while(bank.money &gt;= 300)&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				bank.outMoney(300, mode);</span><br><span class="line">			&#125; catch (Exception e1) &#123;</span><br><span class="line">				// TODO Auto-generated catch block</span><br><span class="line">				e1.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			try &#123;</span><br><span class="line">				sleep(100);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				// TODO Auto-generated catch block</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;余额不足！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PersonB类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PersonB extends Thread &#123;</span><br><span class="line">	Bank bank;</span><br><span class="line">	</span><br><span class="line">	String mode;</span><br><span class="line"> </span><br><span class="line">	public PersonB(Bank bank, String mode) &#123;</span><br><span class="line">		this.bank = bank;</span><br><span class="line">		this.mode = mode;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	public void run() &#123;</span><br><span class="line">		while (bank.money &gt;= 200) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				bank.outMoney(200, mode);</span><br><span class="line">			&#125; catch (Exception e1) &#123;</span><br><span class="line">				// TODO Auto-generated catch block</span><br><span class="line">				e1.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			try &#123;</span><br><span class="line">				sleep(100);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				// TODO Auto-generated catch block</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Four &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Bank bank = new Bank();</span><br><span class="line">		// 实例化两个人，传入同一个银行的对象</span><br><span class="line">		PersonA a = new PersonA(bank, &quot;Counter&quot;);</span><br><span class="line">		PersonB b = new PersonB(bank, &quot;ATM&quot;);</span><br><span class="line">		a.start();</span><br><span class="line">		b.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>python实验六</title>
    <url>/2021/10/21/python%E5%AE%9E%E9%AA%8C%E5%85%AD/</url>
    <content><![CDATA[<h1 id="第二部分第九题"><a href="#第二部分第九题" class="headerlink" title="第二部分第九题"></a>第二部分第九题</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin=df.sort_values(by=&#x27;adcode&#x27;)[[&quot;city&quot;,&quot;city_code&quot;]].drop_duplicates()</span><br><span class="line">for code in admin.values:</span><br><span class="line">	name=code[0]</span><br><span class="line">	dfcountry=df.loc[df[&quot;city&quot;]==name]</span><br><span class="line">	yep=pd.crosstab(values=dfcoutry[&quot;area&quot;],index=dfcountry[&quot;district&quot;],columns=dfcountry[&quot;一级lu2010&quot;],aggfunc=np.sum,margins=True,margins_name=&quot;总计&quot;）</span><br><span class="line">	yep.columns=luname#luname是那个类型的列表</span><br><span class="line">	yep.to_csv(URL+str(code[1])+&quot;_&quot;+name+&quot;各县市土地利用面积统计表.xls&quot;,encoding=&quot;utf_8_sig&quot;)</span><br><span class="line">	print(&quot;finish&quot;)</span><br></pre></td></tr></table></figure>

<p>在操作的时候数据有时候因为误点其他位置会变成0，需要重新执行导入操作；<br>写入表格的时候，需要注意写入URL，路径尽量用英文字母，不要出现中文。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/07/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>A-SOUL</title>
    <url>/2021/10/03/A-SOUL/</url>
    <content><![CDATA[<ul>
<li>一个魂必听<br>  <a href="https://www.bilibili.com/video/BV1p5411w71j">枝江</a></li>
</ul>
]]></content>
      <categories>
        <category>MUSIC</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇文章</title>
    <url>/2021/07/25/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>宅舞推荐</title>
    <url>/2021/09/29/%E5%AE%85%E8%88%9E%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<ul>
<li>one<br>  <a href="https://www.bilibili.com/video/BV1FP4y1a7tL?spm_id_from=333.999.0.0">招商银行娴娴-花月成双</a><br>  <a href="https://www.bilibili.com/video/BV1UA411376M?spm_id_from=333.999.0.0">招商银行娴娴-与梦盛开</a><br>  <a href="https://www.bilibili.com/video/BV1JX4y1c7CQ/?spm_id_from=333.788.recommend_more_video.-1">招商银行娴娴-向阳</a></li>
</ul>
]]></content>
      <categories>
        <category>宅舞</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之苹果橘子问题</title>
    <url>/2022/06/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%8B%B9%E6%9E%9C%E6%A9%98%E5%AD%90%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="怎么去拥有一道彩虹，怎么去拥抱一夏天的风"><a href="#怎么去拥有一道彩虹，怎么去拥抱一夏天的风" class="headerlink" title="怎么去拥有一道彩虹，怎么去拥抱一夏天的风"></a>怎么去拥有一道彩虹，怎么去拥抱一夏天的风</h2><p>简介：<br>桌上有一只盘子，每次只能放入一只水果；爸爸专向盘子中放苹果（apple），妈妈专向盘子中放橘子（orange），一个儿子专等吃盘子中的橘子，一个女儿专等吃盘子中的苹果。<br>分析：<br>至少需要定义三个信号量（本题我多定义了一个信号量，用来实现互斥），分别代表盘子是否为空，盘子里是否有橘子，盘子里是否有苹果；要创建四个进程，分别代表爸爸，妈妈，女儿，和儿子。<br><em><strong>代码请点击“阅读全文”</strong></em></p>
<span id="more"></span>

<p>首先需要一些写好的基本操作</p>
<hr>
<h3 id="p-c"><a href="#p-c" class="headerlink" title="p.c"></a>p.c</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;pv.h&quot;</span><br><span class="line">int p(int semid)</span><br><span class="line">&#123;</span><br><span class="line">struct sembuf p_buf;</span><br><span class="line"></span><br><span class="line">  p_buf.sem_num=0;</span><br><span class="line">  p_buf.sem_op=-1;        //信号量减1，注意这一行的1前面有个负号</span><br><span class="line">  p_buf.sem_flg=0;</span><br><span class="line"></span><br><span class="line">   if (semop(semid, &amp;p_buf, 1)==-1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;p(semid)failed&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="v-c"><a href="#v-c" class="headerlink" title="v.c"></a>v.c</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;pv.h&quot;</span><br><span class="line">int v(int semid)</span><br><span class="line">&#123;</span><br><span class="line">  struct sembuf v_buf;</span><br><span class="line"></span><br><span class="line">  v_buf.sem_num=0;</span><br><span class="line">  v_buf.sem_op=1;    //信号量加1</span><br><span class="line">  v_buf.sem_flg=0;</span><br><span class="line"></span><br><span class="line">  if (semop(semid, &amp;v_buf, 1)==-1)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(&quot;v(semid)failed&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="initsem-c"><a href="#initsem-c" class="headerlink" title="initsem.c"></a>initsem.c</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;pv.h&quot;</span><br><span class="line">int initsem(key_t semkey,int val)</span><br><span class="line">&#123;</span><br><span class="line">   int status=0,semid;                    //信号量标识符semid</span><br><span class="line">  if ((semid=semget(semkey,1,SEMPERM|IPC_CREAT|IPC_EXCL))==-1)</span><br><span class="line">  &#123;</span><br><span class="line">    if (errno==EEXIST)             //EEXIST：信号量集已经存在，无法创建</span><br><span class="line">      semid=semget(semkey,1,0);      //创建一个信号量</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    semun arg;</span><br><span class="line">    arg.val=val;                                        //信号量的初值</span><br><span class="line">    status=semctl(semid,0,SETVAL,arg);</span><br><span class="line">    //设置信号量集中的一个单独的信号量的值。</span><br><span class="line">  &#125;</span><br><span class="line">    if (semid==-1||status==-1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;initsem failed&quot;);</span><br><span class="line">        return(-1);</span><br><span class="line">     &#125;</span><br><span class="line">        /*all ok*/</span><br><span class="line">  return(semid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="pv-h"><a href="#pv-h" class="headerlink" title="pv.h"></a>pv.h</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/sem.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define SEMPERM 0600</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">typedef union _semun</span><br><span class="line">&#123;</span><br><span class="line">  int val;</span><br><span class="line">  struct semid_ds *buf;</span><br><span class="line">  ushort *array;</span><br><span class="line">&#125; semun;</span><br></pre></td></tr></table></figure>
<hr>
<p>然后是测试函数</p>
<h3 id="test-c"><a href="#test-c" class="headerlink" title="test.c"></a>test.c</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;pv.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  key_t semkey_A=0x200;</span><br><span class="line">  key_t semkey_B=0x220;</span><br><span class="line">  key_t semkey_C=0x240;</span><br><span class="line">  key_t semkey_D=0x260;</span><br><span class="line">  int semid_A,semid_B,semid_C,semid_D;</span><br><span class="line">  if ((semid_A=initsem(semkey_A,1))&lt;0) exit(1);//盘子</span><br><span class="line">  if ((semid_B=initsem(semkey_B,0))&lt;0) exit(1);//橘子</span><br><span class="line">  if ((semid_C=initsem(semkey_C,0))&lt;0) exit(1);//苹果</span><br><span class="line">  if ((semid_D=initsem(semkey_D,1))&lt;0) exit(1);//互斥</span><br><span class="line">  printf(&quot;A de %d,chu shi zhi %d\n&quot;,</span><br><span class="line">           semid_A,semctl(semid_A, 0, GETVAL));</span><br><span class="line">  printf(&quot;B de %d,chu shi zhi %d\n&quot;,</span><br><span class="line">           semid_B,semctl(semid_B, 0, GETVAL));</span><br><span class="line">  printf(&quot;C de %d,chu shi zhi %d\n&quot;,</span><br><span class="line">           semid_C,semctl(semid_C, 0, GETVAL));</span><br><span class="line">  printf(&quot;D de %d,chu shi zhi %d\n&quot;,</span><br><span class="line">           semid_D,semctl(semid_D, 0, GETVAL));</span><br><span class="line"></span><br><span class="line">	pid_t pid1; </span><br><span class="line">	pid_t pid2;</span><br><span class="line">	pid1=fork();   </span><br><span class="line">	pid2=fork();</span><br><span class="line"></span><br><span class="line">if(pid1==0&amp;&amp;pid2==0)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i=0;i&lt;5;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      p(semid_A);</span><br><span class="line">      p(semid_D);</span><br><span class="line">      printf(&quot;爸爸放入苹果 得：%d\n&quot;,semctl(semid_A, 0, GETVAL));</span><br><span class="line">      v(semid_D);</span><br><span class="line">      v(semid_C);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(pid1==0&amp;&amp;pid2&gt;0)</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    for (j=0;j&lt;5;j++)</span><br><span class="line">    &#123;</span><br><span class="line">      p(semid_A);</span><br><span class="line">      p(semid_D);</span><br><span class="line">      printf(&quot;妈妈放入橘子 得：%d\n&quot;,semctl(semid_A, 0, GETVAL));</span><br><span class="line">      v(semid_D);</span><br><span class="line">      v(semid_B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(pid1&gt;0&amp;&amp;pid2==0)</span><br><span class="line">&#123;</span><br><span class="line">    int k;</span><br><span class="line">    for (k=0;k&lt;5;k++)</span><br><span class="line">    &#123;</span><br><span class="line">      p(semid_B);</span><br><span class="line">      p(semid_D);</span><br><span class="line">      printf(&quot;儿子拿了橘子 得：%d\n&quot;,semctl(semid_A, 0, GETVAL));</span><br><span class="line">      v(semid_D);</span><br><span class="line">      v(semid_A);</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(pid1&gt;0&amp;&amp;pid2&gt;0)</span><br><span class="line">&#123;</span><br><span class="line">    int l;</span><br><span class="line">    for (l=0;l&lt;5;l++)</span><br><span class="line">    &#123;</span><br><span class="line">      p(semid_C);</span><br><span class="line">      p(semid_D);</span><br><span class="line">      printf(&quot;女儿拿了苹果 得：%d\n&quot;,semctl(semid_A, 0, GETVAL));</span><br><span class="line">      v(semid_D);</span><br><span class="line">      v(semid_A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>三行情诗</title>
    <url>/2022/04/03/%E4%B8%89%E8%A1%8C%E6%83%85%E8%AF%97/</url>
    <content><![CDATA[<p><strong>“螃蟹在剥我的壳 笔记本在写我</strong><br><strong>漫天的我落在枫叶上雪花上</strong><br><strong>而你在想我”</strong></p>
]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习通</title>
    <url>/2021/10/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E9%80%9A/</url>
    <content><![CDATA[<h1 id="作业二线性表（算法部分）"><a href="#作业二线性表（算法部分）" class="headerlink" title="作业二线性表（算法部分）"></a>作业二线性表（算法部分）</h1><h2 id="16"><a href="#16" class="headerlink" title="16"></a>16</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void hebing(LinkList &amp;LA,LinkList &amp;LB,LinkList &amp;LC)</span><br><span class="line">&#123;</span><br><span class="line">LNode *pa;LNode *pb;LNode *pc;</span><br><span class="line">pa=LA-&gt;next;</span><br><span class="line">pb=LB-&gt;next;</span><br><span class="line">LC=LA;</span><br><span class="line">pc=LC;</span><br><span class="line">while (pa&amp;&amp;pb)</span><br><span class="line">&#123;</span><br><span class="line">if(pa-&gt;data&lt;pb-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">pc-&gt;next=pa;</span><br><span class="line">pc=pa;</span><br><span class="line">pa=pa-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">else if(pa-&gt;data&gt;pb-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">pc-&gt;next=pb;</span><br><span class="line">pc=pb;</span><br><span class="line">pb=pb-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">pc-&gt;next=pa;</span><br><span class="line">pc=pa;</span><br><span class="line">pa=pa-&gt;next;</span><br><span class="line">pb=pb-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pc-&gt;next=pa?pa:pb;</span><br><span class="line">delete LB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="17"><a href="#17" class="headerlink" title="17"></a>17</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void hebing(Linklist&amp; L1, Linklist&amp; L2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    LNode* p1 = L1-&gt;next;</span><br><span class="line">    LNode* p2 = L2-&gt;next;</span><br><span class="line">    LNode* head = L1;//p3为合成链表的头结点 </span><br><span class="line">    LNode* temp;</span><br><span class="line">    LNode* p3;</span><br><span class="line">    LNode* tail_node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //找出最小的节点作尾节点</span><br><span class="line">    if (p1-&gt;data &lt; p2-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        tail_node = p1;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        tail_node = p2;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    tail_node-&gt;next = NULL;</span><br><span class="line">    p3 = tail_node;//p3用于指向新链表的首元结点，p3此时为尾结点 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    while (p1 &amp;&amp; p2)</span><br><span class="line">    &#123;</span><br><span class="line">        if (p2-&gt;data &lt; p1-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = p2-&gt;next;//因为要将p2插入新链表中，会丢失p2-&gt;next故用temp保存 </span><br><span class="line">            head-&gt;next = p2;</span><br><span class="line">            p2-&gt;next = p3;</span><br><span class="line">            p3 = p2;//p3用于指向新链表的首元结点</span><br><span class="line">            p2 = temp;//L2中的结点插入新链表完成，p2重新指向L2中的下一个结点 </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            temp = p1-&gt;next;</span><br><span class="line">            head-&gt;next = p1;</span><br><span class="line">            p1-&gt;next = p3;</span><br><span class="line">            p3 = p1;</span><br><span class="line">            p1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //有链表没有遍历完 </span><br><span class="line"></span><br><span class="line">    if (p1 != NULL || p2 != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        if (p1 != NULL)//p1还有剩下的还没有插入L3的结点 </span><br><span class="line">        &#123;</span><br><span class="line">            while (p1)//将L1中剩下的结点插入L3中 </span><br><span class="line">            &#123;</span><br><span class="line">                temp = p1-&gt;next;</span><br><span class="line">                head-&gt;next = p1;</span><br><span class="line">                p1-&gt;next = p3;</span><br><span class="line">                p3 = p1;</span><br><span class="line">                p1 = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (p2 != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            while (p2)//将L2中剩下的结点插入L3中 </span><br><span class="line">            &#123;</span><br><span class="line">                temp = p2-&gt;next;</span><br><span class="line">                head-&gt;next = p2;</span><br><span class="line">                p2-&gt;next = p3;</span><br><span class="line">                p3 = p2;</span><br><span class="line">                p2 = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18"><a href="#18" class="headerlink" title="18"></a>18</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Intersection(LinkList &amp;L1, LinkList &amp;L2, LinkList &amp;L3)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">LNode *p1, *p2, *p3, *q, *u;</span><br><span class="line">p1 = L1-&gt;next;</span><br><span class="line">p2 = L2-&gt;next;  // p1和p2分别是链表L1和L2的工作指针,初始化为相应链表的第一个结点</span><br><span class="line">p3 = L3 = L1;   // 用L1的头结点作为L3的头结点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while (p1&amp;&amp;p2)</span><br><span class="line">&#123;</span><br><span class="line">if (p1-&gt;data == p2-&gt;data)    //交集并入结果表中。</span><br><span class="line">&#123; </span><br><span class="line">p3-&gt;next = p1; </span><br><span class="line">p3 = p1; </span><br><span class="line">p1 = p1-&gt;next;</span><br><span class="line">u = p2; </span><br><span class="line">p2 = p2-&gt;next; </span><br><span class="line">delete u; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else if (p1-&gt;data &lt; p2-&gt;data) </span><br><span class="line">&#123; </span><br><span class="line">u = p1; </span><br><span class="line">p1 = p1-&gt;next; </span><br><span class="line">delete u; </span><br><span class="line">&#125;</span><br><span class="line">else </span><br><span class="line">&#123; </span><br><span class="line">u = p2; </span><br><span class="line">p2 = p2-&gt;next; </span><br><span class="line">delete u; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while (p1) // 释放结点空间</span><br><span class="line">&#123; </span><br><span class="line">u = p1;</span><br><span class="line">p1 = p1-&gt;next; </span><br><span class="line">delete u; </span><br><span class="line">&#125;</span><br><span class="line">while (p2)   // 释放结点空间</span><br><span class="line">&#123;</span><br><span class="line">u = p2; </span><br><span class="line">p2 = p2-&gt;next; </span><br><span class="line">delete u;</span><br><span class="line">&#125;</span><br><span class="line">p3-&gt;next = NULL;    // 置链表尾标记。</span><br><span class="line">delete L2;    // 释放Lb的头结点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19"><a href="#19" class="headerlink" title="19"></a>19</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Difference(Linklist &amp;La, Linklist &amp;Lb, int &amp;n)</span><br><span class="line">&#123;</span><br><span class="line">    Linklist pa = La-&gt;next;</span><br><span class="line">    Linklist pb = Lb-&gt;next;</span><br><span class="line">    Linklist pre = La;</span><br><span class="line">    while (pa &amp;&amp; pb)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        if (pa-&gt;date &lt; pb-&gt;date)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = pa;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (pa-&gt;date &gt; pb-&gt;date)</span><br><span class="line">        &#123;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;next = pa-&gt;next;</span><br><span class="line">            Linklist u = pre;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">            delete u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20"><a href="#20" class="headerlink" title="20"></a>20</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Resolve(Linklist &amp;La, Linklist &amp;Lb,Linklist &amp;Lc)</span><br><span class="line">&#123;</span><br><span class="line">    Linklist pre = La;</span><br><span class="line">    Linklist pb = Lb;</span><br><span class="line">    Linklist pa = La;</span><br><span class="line">    Linklist pc = Lc;</span><br><span class="line">    pa = pa-&gt;next;</span><br><span class="line">    while (pa)</span><br><span class="line">    &#123;</span><br><span class="line">        if (pa-&gt;date &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            Linklist p = new Lnode;</span><br><span class="line">            p = pa;               //生成新节点</span><br><span class="line">            pre-&gt;next = pa-&gt;next; //删除小于0的节点，pre始终为pa的前驱</span><br><span class="line">            pa = pa-&gt;next;        //pa后移</span><br><span class="line">            p-&gt;next = NULL;       //后插法将元素插入Lb中</span><br><span class="line">            pb-&gt;next = p;</span><br><span class="line">            pb = p; //插入</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">            Linklist p = new Lnode;</span><br><span class="line">            p = pa;               //生成新节点</span><br><span class="line">            pre-&gt;next = pa-&gt;next; </span><br><span class="line">            pa = pa-&gt;next;        //pa后移</span><br><span class="line">            p-&gt;next = NULL;       </span><br><span class="line">            pc-&gt;next = p;</span><br><span class="line">            pc = p; //插入</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="21"><a href="#21" class="headerlink" title="21"></a>21</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int GetMax(LinkList &amp;L)&#123;</span><br><span class="line">if(L-&gt;next == NULL)</span><br><span class="line">return NULL;</span><br><span class="line">pmax = L-&gt;next;</span><br><span class="line">p = L-&gt;next-&gt;next;</span><br><span class="line">while (p)&#123;</span><br><span class="line">if(p-&gt;data &gt; pmax-&gt;data)</span><br><span class="line">pmax = p; </span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return pmax-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="22"><a href="#22" class="headerlink" title="22"></a>22</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void reverse(Node* head) &#123;</span><br><span class="line">Node* remain, * p, * q;</span><br><span class="line">remain = head-&gt;next;</span><br><span class="line">head-&gt;next = nullptr;</span><br><span class="line">while (remain != nullptr) &#123;</span><br><span class="line">p = remain;</span><br><span class="line">remain = remain-&gt;next;</span><br><span class="line">p-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="23"><a href="#23" class="headerlink" title="23"></a>23</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void del(Linklist &amp;h,int mink,int maxk)</span><br><span class="line">&#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    p=h;</span><br><span class="line">    while(p)</span><br><span class="line">      &#123;</span><br><span class="line">           if(p-&gt;next-&gt;data&gt;mink&amp;&amp;p-&gt;next-&gt;data&lt;maxk)</span><br><span class="line">              &#123;</span><br><span class="line">       p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line">   p=p-&gt;next;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24"><a href="#24" class="headerlink" title="24"></a>24</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Change(LinkList p)   //核心算法</span><br><span class="line">&#123;</span><br><span class="line">DLnode *q;</span><br><span class="line">q = p-&gt;prior;</span><br><span class="line">q-&gt;prior-&gt;next = p;          // p的前驱的前驱之后继为p</span><br><span class="line">p-&gt;prior = q-&gt;prior;    // p的前驱指向其前驱的前驱。</span><br><span class="line">q-&gt;next = p-&gt;next;    // p的前驱的后继为p的后继。 </span><br><span class="line">p-&gt;next-&gt;prior = q;   // p的后继的前驱指向原p的前驱</span><br><span class="line">q-&gt;prior = p;     // p与其前驱交换</span><br><span class="line">p-&gt;next = q;    // p的后继指向其原来的前驱</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="25"><a href="#25" class="headerlink" title="25"></a>25</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void DeleteItem (Sqlist *L,int item)</span><br><span class="line">&#123;</span><br><span class="line">   int i=0,j=0,count=0;</span><br><span class="line">for(i=0;i&lt;L-&gt;length;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(L-&gt;elem[i] == item)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;//下一个节点下标</span><br><span class="line">            count++;//数据为item的个数</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;elem[j] = L-&gt;elem[i];//j为需要插入元素的下标</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length -= count;//更改表长</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构实验1</title>
    <url>/2021/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C1/</url>
    <content><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><h2 id="8559"><a href="#8559" class="headerlink" title="8559"></a>8559</h2><p><code>线性表逆置</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Node &#123;</span><br><span class="line">	int data;</span><br><span class="line">	Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void show(Node* head) &#123;</span><br><span class="line">	head = head-&gt;next;</span><br><span class="line">	while (head != nullptr) &#123;</span><br><span class="line">		cout &lt;&lt; head-&gt;data &lt;&lt; &quot; &quot;;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reverse(Node* head) &#123;</span><br><span class="line">	Node* remain, * p, * q;</span><br><span class="line">	remain = head-&gt;next;</span><br><span class="line">	head-&gt;next = nullptr;</span><br><span class="line">	while (remain != nullptr) &#123;</span><br><span class="line">		p = remain;</span><br><span class="line">		remain = remain-&gt;next;</span><br><span class="line">		p-&gt;next = head-&gt;next;</span><br><span class="line">		head-&gt;next = p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int num;</span><br><span class="line">	int n;</span><br><span class="line">	Node* first, * p, * rear;</span><br><span class="line">	first = new Node;</span><br><span class="line">	first-&gt;next = nullptr;</span><br><span class="line">	rear = first;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; num;</span><br><span class="line">		</span><br><span class="line">		p = new Node;</span><br><span class="line">		p-&gt;data = num;</span><br><span class="line">		p-&gt;next = nullptr;</span><br><span class="line"></span><br><span class="line">		rear-&gt;next = p;</span><br><span class="line">		rear = rear-&gt;next;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;原链表为：&quot;;</span><br><span class="line">	show(first);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	reverse(first);</span><br><span class="line">	cout &lt;&lt; &quot;逆置链表为：&quot;;</span><br><span class="line">	show(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="8556"><a href="#8556" class="headerlink" title="8556"></a>8556</h2><p><code>删除偶数结点</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Come I Here World Hello</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#define Elemtype int</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Node &#123;</span><br><span class="line">	int data;</span><br><span class="line">	Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void show(Node* head) &#123;</span><br><span class="line">	head = head-&gt;next;</span><br><span class="line">	while (head != nullptr) &#123;</span><br><span class="line">		cout &lt;&lt; head-&gt;data &lt;&lt; &quot; &quot;;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reverse(Node* head) &#123;</span><br><span class="line">	Node* remain, * p, * q;</span><br><span class="line">	remain = head-&gt;next;</span><br><span class="line">	head-&gt;next = nullptr;</span><br><span class="line">	while (remain != nullptr) &#123;</span><br><span class="line">		p = remain;</span><br><span class="line">		remain = remain-&gt;next;</span><br><span class="line">		p-&gt;next = head-&gt;next;</span><br><span class="line">		head-&gt;next = p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Bubble(Node* head)</span><br><span class="line">&#123;</span><br><span class="line">	Node* pre, *cur, *next, *end;//pre前一项 cur当前项 next后一项 end控制循环次数(优化冒泡)</span><br><span class="line">	end = NULL;</span><br><span class="line"></span><br><span class="line">	while (head-&gt;next != end)</span><br><span class="line">	&#123;</span><br><span class="line">		//初始化三个指针 ; 判断是否到达结束位置 ; 三个指针集体后移</span><br><span class="line">		for (pre = head, cur = pre-&gt;next, next = cur-&gt;next; next != end; pre = pre-&gt;next, cur = cur-&gt;next, next = next-&gt;next)</span><br><span class="line">		&#123;</span><br><span class="line">			if (cur-&gt;data &gt; next-&gt;data) //从小到大</span><br><span class="line">			&#123;</span><br><span class="line">				pre-&gt;next = next;</span><br><span class="line">				cur-&gt;next = next-&gt;next;</span><br><span class="line">				next-&gt;next = cur;</span><br><span class="line"></span><br><span class="line">				//此时next变前一项，cur变后一项  交换next cur</span><br><span class="line">				Node* temp = cur; cur = next; next = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//一轮循环结束 最后一项已经排好 end提前一项 (冒泡原理)</span><br><span class="line">		end = cur;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void del(Node* h)</span><br><span class="line">&#123;</span><br><span class="line">	Node* p,*q;</span><br><span class="line">	p = h;</span><br><span class="line">	while (p &amp;&amp; p-&gt;next) &#123;</span><br><span class="line">		while (p-&gt;next &amp;&amp; p-&gt;next-&gt;data % 2 == 0) &#123;</span><br><span class="line">			q = p-&gt;next;</span><br><span class="line">			p-&gt;next = q-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int num;</span><br><span class="line"></span><br><span class="line">	Node* first, * p, * rear;</span><br><span class="line">	first = new Node;</span><br><span class="line">	first-&gt;next = nullptr;</span><br><span class="line">	rear = first;</span><br><span class="line"></span><br><span class="line">	//cout &lt;&lt; &quot;请输入数据：   0代表输入结束&quot; &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">	cin &gt;&gt; num;</span><br><span class="line">	while (num != 0) &#123;</span><br><span class="line">		p = new Node;</span><br><span class="line">		p-&gt;data = num;</span><br><span class="line">		p-&gt;next = nullptr;</span><br><span class="line"></span><br><span class="line">		rear-&gt;next = p;</span><br><span class="line">		rear = rear-&gt;next;</span><br><span class="line">		cin &gt;&gt; num;</span><br><span class="line">	&#125;</span><br><span class="line">	del(first);//删除偶数结点</span><br><span class="line">	show(first);//输出函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8557"><a href="#8557" class="headerlink" title="8557"></a>8557</h2><p><code>建立两个非递减序列，合成非递增序列</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;malloc.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct Node* next;</span><br><span class="line">&#125;LinkNode, * Linklist;</span><br><span class="line">/*</span><br><span class="line">    初始化链表</span><br><span class="line">*/</span><br><span class="line">Linklist Initlist()</span><br><span class="line">&#123;</span><br><span class="line">    Linklist L;</span><br><span class="line">    L = (Linklist)malloc(sizeof(LinkNode));</span><br><span class="line">    L-&gt;next = NULL;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">    尾插法建立链表</span><br><span class="line">*/</span><br><span class="line">void CreatFromTail(Linklist L)</span><br><span class="line">&#123;</span><br><span class="line">    int data = -1;</span><br><span class="line">    Linklist s, tail;</span><br><span class="line">    tail = L;</span><br><span class="line">    cin &gt;&gt; data;</span><br><span class="line">    while (data != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        s = (Linklist)malloc(sizeof(LinkNode));</span><br><span class="line">        s-&gt;data = data;</span><br><span class="line">        tail-&gt;next = s;</span><br><span class="line">        tail = s;</span><br><span class="line">        cin &gt;&gt; data;</span><br><span class="line">    &#125;</span><br><span class="line">    tail-&gt;next = NULL;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">    输出链表</span><br><span class="line">*/</span><br><span class="line">void PrintList(Linklist L)</span><br><span class="line">&#123;</span><br><span class="line">    Linklist p = L-&gt;next;</span><br><span class="line">    while (p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">    合并链表</span><br><span class="line">*/</span><br><span class="line">void merge(Linklist LA, Linklist LB)</span><br><span class="line">&#123;</span><br><span class="line">    Linklist p = LA-&gt;next;</span><br><span class="line">    while (p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = LB-&gt;next;</span><br><span class="line">    free(LB);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Bubble(Node* head)</span><br><span class="line">&#123;</span><br><span class="line">    Node* pre, * cur, * next, * end;//pre前一项 cur当前项 next后一项 end控制循环次数(优化冒泡)</span><br><span class="line">    end = NULL;</span><br><span class="line"></span><br><span class="line">    while (head-&gt;next != end)</span><br><span class="line">    &#123;</span><br><span class="line">        //初始化三个指针 ; 判断是否到达结束位置 ; 三个指针集体后移</span><br><span class="line">        for (pre = head, cur = pre-&gt;next, next = cur-&gt;next; next != end; pre = pre-&gt;next, cur = cur-&gt;next, next = next-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            if (cur-&gt;data &lt; next-&gt;data) //从大到小</span><br><span class="line">            &#123;</span><br><span class="line">                pre-&gt;next = next;</span><br><span class="line">                cur-&gt;next = next-&gt;next;</span><br><span class="line">                next-&gt;next = cur;</span><br><span class="line"></span><br><span class="line">                //此时next变前一项，cur变后一项  交换next cur</span><br><span class="line">                Node* temp = cur; cur = next; next = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //一轮循环结束 最后一项已经排好 end提前一项 (冒泡原理)</span><br><span class="line">        end = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Linklist LA, LB;</span><br><span class="line">    LA = Initlist();</span><br><span class="line">    LB = Initlist();</span><br><span class="line">    CreatFromTail(LA);</span><br><span class="line">    CreatFromTail(LB);</span><br><span class="line">    merge(LA, LB);</span><br><span class="line">    Bubble(LA);</span><br><span class="line">    PrintList(LA);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8558"><a href="#8558" class="headerlink" title="8558"></a>8558</h2><p><code>一个链表分解为两个，一个全是奇数一个全是偶数</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Node &#123;</span><br><span class="line">	int data;</span><br><span class="line">	Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void show(Node* head) &#123;</span><br><span class="line">	head = head-&gt;next;</span><br><span class="line">	while (head != nullptr) &#123;</span><br><span class="line">		cout &lt;&lt; head-&gt;data &lt;&lt; &quot; &quot;;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void chai(Node* head,Node *head1,Node* head2)</span><br><span class="line">&#123;</span><br><span class="line">	Node* p, * q,*tail1,*tail2;</span><br><span class="line">	p = head-&gt;next;</span><br><span class="line">	q = p-&gt;next;</span><br><span class="line">	tail1 = head1;</span><br><span class="line">	tail2 = head2;</span><br><span class="line">	while (p)</span><br><span class="line">	&#123;</span><br><span class="line">		if (p-&gt;data % 2 == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;next = NULL;//这里还是要让他指向NULL，不然建立完的链表在输出又会出问题</span><br><span class="line">			tail2-&gt;next = p;</span><br><span class="line">			tail2 = p;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;next = NULL;</span><br><span class="line">			tail1-&gt;next = p;</span><br><span class="line">			tail1 = p;</span><br><span class="line">		&#125;</span><br><span class="line">		p = q;</span><br><span class="line">		if (q)</span><br><span class="line">			q = q-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int num;</span><br><span class="line"></span><br><span class="line">	Node* first, * p, * rear,*head1,*head2;</span><br><span class="line">	first = new Node;</span><br><span class="line">	first-&gt;next = nullptr;</span><br><span class="line">	rear = first;</span><br><span class="line"></span><br><span class="line">	//cout &lt;&lt; &quot;请输入数据：   0代表输入结束&quot; &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">	cin &gt;&gt; num;</span><br><span class="line">	while (num != 0) &#123;</span><br><span class="line">		p = new Node;</span><br><span class="line">		p-&gt;data = num;</span><br><span class="line">		p-&gt;next = nullptr;</span><br><span class="line"></span><br><span class="line">		rear-&gt;next = p;</span><br><span class="line">		rear = rear-&gt;next;</span><br><span class="line">		cin &gt;&gt; num;</span><br><span class="line">	&#125;</span><br><span class="line">	head1 = new Node;</span><br><span class="line">	head2 = new Node;</span><br><span class="line">	head1-&gt;next = NULL;</span><br><span class="line">	head2-&gt;next = NULL;</span><br><span class="line">	chai(first,head1,head2);</span><br><span class="line">	show(head1);//输出函数</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	show(head2);//输出函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8560"><a href="#8560" class="headerlink" title="8560"></a>8560</h2><p><code>多项式相加</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct PNode &#123;</span><br><span class="line">	float coef;//系数</span><br><span class="line">	int expn;  //指数</span><br><span class="line">	struct PNode* next;</span><br><span class="line">&#125;PNode, * Polynomial;</span><br><span class="line"></span><br><span class="line">void initPolyn(Polynomial&amp; p) &#123;</span><br><span class="line">	p = new PNode;</span><br><span class="line">	p-&gt;next = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CreatePolyn(Polynomial&amp; P, int n) &#123;</span><br><span class="line">	Polynomial s, pre, q;</span><br><span class="line">	P = new PNode;</span><br><span class="line">	P-&gt;next = NULL;</span><br><span class="line">	for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		s = new PNode;</span><br><span class="line">		char b;</span><br><span class="line">		cin &gt;&gt; s-&gt;coef &gt;&gt;b&gt;&gt; s-&gt;expn;</span><br><span class="line">		pre = P;</span><br><span class="line">		q = P-&gt;next;</span><br><span class="line">		while (q &amp;&amp; q-&gt;expn &lt; s-&gt;expn) &#123;</span><br><span class="line">			pre = q;</span><br><span class="line">			q = q-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		s-&gt;next = q;</span><br><span class="line">		pre-&gt;next = s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cout_L(Polynomial l, int n)// 打印链表的数据，以作检验</span><br><span class="line">&#123;</span><br><span class="line">	Polynomial p;</span><br><span class="line">	p = l-&gt;next;</span><br><span class="line">	cout &lt;&lt; p-&gt;coef &lt;&lt; &quot;*x^&quot; &lt;&lt; p-&gt;expn;</span><br><span class="line">	p = p-&gt;next;</span><br><span class="line">	for (int i = 1; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot; &quot;;</span><br><span class="line">		cout &lt;&lt; p-&gt;coef &lt;&lt; &quot;*x^&quot; &lt;&lt; p-&gt;expn;</span><br><span class="line"></span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int number_L(Polynomial M) &#123;</span><br><span class="line">	Polynomial P;</span><br><span class="line">	int i = 1;</span><br><span class="line">	P = M-&gt;next;</span><br><span class="line">	while (P != NULL) </span><br><span class="line">	&#123;</span><br><span class="line">		P = P-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void merge_L(Polynomial&amp; la, Polynomial&amp; lb, Polynomial&amp; lc)</span><br><span class="line">&#123;</span><br><span class="line">	Polynomial pa, pb, pc;</span><br><span class="line">	pa = la-&gt;next;</span><br><span class="line">	pb = lb-&gt;next;</span><br><span class="line">	pc = lc = la;</span><br><span class="line"></span><br><span class="line">	while (pa &amp;&amp; pb)</span><br><span class="line">	&#123;</span><br><span class="line">		if (pa-&gt;expn == pb-&gt;expn)</span><br><span class="line">		&#123;</span><br><span class="line">			pa-&gt;coef = pa-&gt;coef + pb-&gt;coef;</span><br><span class="line">			if (pa-&gt;coef == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				pa = pa-&gt;next;</span><br><span class="line">				pb = pb-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">			pc-&gt;next = pa;</span><br><span class="line">			pc = pa;</span><br><span class="line">			pa = pa-&gt;next;</span><br><span class="line">			pb = pb-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (pa-&gt;expn &gt; pb-&gt;expn)</span><br><span class="line">		&#123;</span><br><span class="line">			pc-&gt;next = pb;</span><br><span class="line">			pc = pb;</span><br><span class="line">			pb = pb-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (pa-&gt;expn &lt; pb-&gt;expn)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			pc-&gt;next = pa;</span><br><span class="line">			pc = pa;</span><br><span class="line">			pa = pa-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pc-&gt;next = pa ? pa : pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	Polynomial La, Lb, Lc;</span><br><span class="line">	int a, b, H;</span><br><span class="line">	cout &lt;&lt; &quot;输入第一个多项式的个数&quot; &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; a;</span><br><span class="line">	cout &lt;&lt; &quot;输入第一个多项式的系数和个数&quot; &lt;&lt; endl;</span><br><span class="line">	CreatePolyn(La, a);</span><br><span class="line">	cout &lt;&lt; &quot;输入第二个多项式的个数&quot; &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; b;</span><br><span class="line">	cout &lt;&lt; &quot;输入第二个多项式的系数和个数&quot; &lt;&lt; endl;</span><br><span class="line">	CreatePolyn(Lb, b);</span><br><span class="line">	initPolyn(Lc);</span><br><span class="line">	merge_L(La, Lb, Lc);</span><br><span class="line">	H = number_L(Lc);</span><br><span class="line">	cout &lt;&lt; &quot;新合并的多项式为：&quot;;</span><br><span class="line">	cout_L(Lc, H - 1);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构实验5</title>
    <url>/2021/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C5/</url>
    <content><![CDATA[<h2 id="7043"><a href="#7043" class="headerlink" title="7043"></a>7043</h2><p><code>利用邻接表实现无向图的广度优先遍历</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct ArcNode &#123;</span><br><span class="line"></span><br><span class="line">    int adjvex;</span><br><span class="line">	struct ArcNode* nextArc;</span><br><span class="line"></span><br><span class="line">&#125;ArcNode;	//边节点</span><br><span class="line"></span><br><span class="line">typedef struct VNode &#123;</span><br><span class="line"></span><br><span class="line">	int data;</span><br><span class="line">	ArcNode* firstArc;</span><br><span class="line"></span><br><span class="line">&#125;VNode, * AdjList;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line"></span><br><span class="line">	int vNum, arcNum;//分别是点数和边数</span><br><span class="line">	AdjList vertices;</span><br><span class="line"></span><br><span class="line">&#125;ALGraph;</span><br><span class="line"></span><br><span class="line">int LocateVNode(ALGraph g, int index) &#123;</span><br><span class="line">	int flag = 0;</span><br><span class="line">	for (int i = 0; i &lt; g.vNum; i++) &#123;</span><br><span class="line">		if (g.vertices[i].data==index) &#123;</span><br><span class="line">			flag = 1;</span><br><span class="line">			return i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (flag == 0) &#123;</span><br><span class="line">		return -1;//查找失败</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int CreateUDG(ALGraph&amp; g) &#123;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; g.vNum &gt;&gt; g.arcNum;</span><br><span class="line">	g.vertices = new VNode[g.vNum];</span><br><span class="line">	for (int i = 0; i &lt; g.vNum; i++) &#123;</span><br><span class="line">		cin &gt;&gt; g.vertices[i].data;</span><br><span class="line">		g.vertices[i].firstArc = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 0; i &lt; g.arcNum; i++) &#123;</span><br><span class="line">		int v1, v2;</span><br><span class="line">		cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">		v1 = LocateVNode(g, v1);</span><br><span class="line">		v2 = LocateVNode(g, v2);</span><br><span class="line"></span><br><span class="line">		ArcNode* p1 = new ArcNode;</span><br><span class="line">		p1-&gt;adjvex = v2 + 1;</span><br><span class="line">		p1-&gt;nextArc = g.vertices[v1].firstArc;</span><br><span class="line">		g.vertices[v1].firstArc = p1;</span><br><span class="line">		</span><br><span class="line">		ArcNode* p2 = new ArcNode;</span><br><span class="line">		p2-&gt;adjvex = v1 + 1;</span><br><span class="line">		p2-&gt;nextArc = g.vertices[v2].firstArc;</span><br><span class="line">		g.vertices[v2].firstArc = p2;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WidthTraverseGraph(ALGraph g) &#123;</span><br><span class="line"></span><br><span class="line">	queue&lt;int&gt; TraverseList;</span><br><span class="line">	int visited[1000];</span><br><span class="line">	memset(visited, 0, sizeof(visited));</span><br><span class="line">	cout &lt;&lt; &quot;v&quot; &lt;&lt; g.vertices-&gt;data &lt;&lt; &quot; &quot;;</span><br><span class="line">	visited[0] = true;</span><br><span class="line">	TraverseList.push(g.vertices-&gt;data);</span><br><span class="line">	while (!TraverseList.empty()) &#123;</span><br><span class="line">		int u = TraverseList.front();</span><br><span class="line">		TraverseList.pop();</span><br><span class="line">		ArcNode* p = g.vertices[LocateVNode(g,u)].firstArc;</span><br><span class="line">		while (p != NULL) &#123;</span><br><span class="line">			if (!visited[LocateVNode(g, p-&gt;adjvex)]) &#123;</span><br><span class="line">				cout &lt;&lt; &quot;v&quot; &lt;&lt; p-&gt;adjvex &lt;&lt; &quot; &quot;;</span><br><span class="line">				visited[LocateVNode(g, p-&gt;adjvex)] = true;</span><br><span class="line">				TraverseList.push(p-&gt;adjvex);</span><br><span class="line">			&#125;</span><br><span class="line">			p = p-&gt;nextArc;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	ALGraph g;</span><br><span class="line">	CreateUDG(g);</span><br><span class="line">	WidthTraverseGraph(g);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="7039"><a href="#7039" class="headerlink" title="7039"></a>7039</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct ArcNode &#123;</span><br><span class="line"></span><br><span class="line">    int adjvex;</span><br><span class="line">	struct ArcNode* nextArc;</span><br><span class="line"></span><br><span class="line">&#125;ArcNode;	//边节点</span><br><span class="line"></span><br><span class="line">typedef struct VNode &#123;</span><br><span class="line"></span><br><span class="line">	int data;</span><br><span class="line">	ArcNode* firstArc;</span><br><span class="line"></span><br><span class="line">&#125;VNode, * AdjList;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line"></span><br><span class="line">	int vNum, arcNum;</span><br><span class="line">	AdjList vertices;</span><br><span class="line"></span><br><span class="line">&#125;ALGraph;</span><br><span class="line"></span><br><span class="line">int LocateVNode(ALGraph g, int index) &#123;</span><br><span class="line">	int flag = 0;</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; g.vNum; i++) &#123;</span><br><span class="line">		if (g.vertices[i].data==index) &#123;</span><br><span class="line">			flag = 1;</span><br><span class="line">			return i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (flag == 0) &#123;</span><br><span class="line">		return -1;//查找失败</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int CreateUDG(ALGraph&amp; g) &#123;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; g.vNum &gt;&gt; g.arcNum;</span><br><span class="line">	g.vertices = new VNode[g.vNum];</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; g.vNum; i++) &#123;</span><br><span class="line">		cin &gt;&gt; g.vertices[i].data;</span><br><span class="line">		g.vertices[i].firstArc = NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; g.arcNum; i++) &#123;</span><br><span class="line"></span><br><span class="line">		int v1, v2;</span><br><span class="line">		cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">		v1 = LocateVNode(g, v1);</span><br><span class="line">		v2 = LocateVNode(g, v2);</span><br><span class="line"></span><br><span class="line">		ArcNode* p1 = new ArcNode;</span><br><span class="line">		p1-&gt;adjvex = v2 + 1;</span><br><span class="line">		p1-&gt;nextArc = g.vertices[v1].firstArc;</span><br><span class="line">		g.vertices[v1].firstArc = p1;</span><br><span class="line">		</span><br><span class="line">		ArcNode* p2 = new ArcNode;</span><br><span class="line">		p2-&gt;adjvex = v1 + 1;</span><br><span class="line">		p2-&gt;nextArc = g.vertices[v2].firstArc;</span><br><span class="line">		g.vertices[v2].firstArc = p2;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line">int CreateDG(ALGraph&amp; g) &#123;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; g.vNum &gt;&gt; g.arcNum;</span><br><span class="line">	g.vertices = new VNode[g.vNum];</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; g.vNum; i++) &#123;</span><br><span class="line">		cin &gt;&gt; g.vertices[i].data;</span><br><span class="line">		g.vertices[i].firstArc = NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; g.arcNum; i++) &#123;</span><br><span class="line"></span><br><span class="line">		int v1, v2;</span><br><span class="line">		cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">		v1 = LocateVNode(g, v1);</span><br><span class="line">		v2 = LocateVNode(g, v2);</span><br><span class="line"></span><br><span class="line">		ArcNode* p1 = new ArcNode;</span><br><span class="line">		p1-&gt;adjvex = v2 + 1;</span><br><span class="line">		p1-&gt;nextArc = g.vertices[v1].firstArc;</span><br><span class="line">		g.vertices[v1].firstArc = p1;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OutputDGraph(ALGraph g) &#123;</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; g.vNum; i++) &#123;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; g.vertices[i].data &lt;&lt; &quot;:&quot;;</span><br><span class="line">		ArcNode* p = g.vertices[i].firstArc;</span><br><span class="line">		while (p) &#123;</span><br><span class="line">			cout &lt;&lt; p-&gt;adjvex &lt;&lt; &quot; &quot;;</span><br><span class="line">			p = p-&gt;nextArc;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WidthTraverseGraph(ALGraph g) &#123;</span><br><span class="line"></span><br><span class="line">	queue&lt;int&gt; TraverseList;</span><br><span class="line">	int visited[1000];</span><br><span class="line">	memset(visited, 0, sizeof(visited));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;v&quot; &lt;&lt; g.vertices-&gt;data &lt;&lt; &quot; &quot;;</span><br><span class="line">	visited[0] = true;</span><br><span class="line">	TraverseList.push(g.vertices-&gt;data);</span><br><span class="line"></span><br><span class="line">	while (!TraverseList.empty()) &#123;</span><br><span class="line"></span><br><span class="line">		int u = TraverseList.front();</span><br><span class="line">		TraverseList.pop();</span><br><span class="line"></span><br><span class="line">		ArcNode* p = g.vertices[LocateVNode(g,u)].firstArc;</span><br><span class="line"></span><br><span class="line">		while (p != NULL) &#123;</span><br><span class="line">			if (!visited[LocateVNode(g, p-&gt;adjvex)]) &#123;</span><br><span class="line"></span><br><span class="line">				cout &lt;&lt; &quot;v&quot; &lt;&lt; p-&gt;adjvex &lt;&lt; &quot; &quot;;</span><br><span class="line">				visited[LocateVNode(g, p-&gt;adjvex)] = true;</span><br><span class="line">				TraverseList.push(p-&gt;adjvex);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			p = p-&gt;nextArc;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int visited[1000];</span><br><span class="line">void Depth_TG(ALGraph g, int v);</span><br><span class="line"></span><br><span class="line">void DepthTraverseGraph(ALGraph g) &#123;</span><br><span class="line">	</span><br><span class="line">	memset(visited, 0, sizeof(visited));</span><br><span class="line">	for (int i = 0; i &lt; g.vNum; i++) &#123;</span><br><span class="line">		if (visited[i] == 0) &#123;</span><br><span class="line">			Depth_TG(g, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Depth_TG(ALGraph g,int v) &#123;</span><br><span class="line">	cout &lt;&lt; g.vertices[v].data &lt;&lt; &quot; &quot;;</span><br><span class="line">	visited[v] = true;</span><br><span class="line">	ArcNode* p = g.vertices[v].firstArc;</span><br><span class="line">	while (p) &#123;</span><br><span class="line">		int w = LocateVNode(g, p-&gt;adjvex);</span><br><span class="line">		if (!visited[w]) &#123;</span><br><span class="line">			Depth_TG(g, w);</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;nextArc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	ALGraph g;</span><br><span class="line">	CreateDG(g);</span><br><span class="line">	OutputDGraph(g);</span><br><span class="line">	DepthTraverseGraph(g);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7040"><a href="#7040" class="headerlink" title="7040"></a>7040</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct ArcNode &#123;</span><br><span class="line"></span><br><span class="line">    int adjvex;</span><br><span class="line">	struct ArcNode* nextArc;</span><br><span class="line"></span><br><span class="line">&#125;ArcNode;	//边节点</span><br><span class="line"></span><br><span class="line">typedef struct VNode &#123;</span><br><span class="line"></span><br><span class="line">	int data;</span><br><span class="line">	int inDegree, outDegree;</span><br><span class="line">	ArcNode* firstArc;</span><br><span class="line"></span><br><span class="line">&#125;VNode, * AdjList;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line"></span><br><span class="line">	int vNum, arcNum;</span><br><span class="line">	AdjList vertices;</span><br><span class="line"></span><br><span class="line">&#125;ALGraph;</span><br><span class="line"></span><br><span class="line">int LocateVNode(ALGraph g, int index) &#123;</span><br><span class="line">	int flag = 0;</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; g.vNum; i++) &#123;</span><br><span class="line">		if (g.vertices[i].data==index) &#123;</span><br><span class="line">			flag = 1;</span><br><span class="line">			return i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (flag == 0) &#123;</span><br><span class="line">		return -1;//查找失败</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int CreateUDG(ALGraph&amp; g) &#123;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; g.vNum &gt;&gt; g.arcNum;</span><br><span class="line">	g.vertices = new VNode[g.vNum];</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; g.vNum; i++) &#123;</span><br><span class="line">		cin &gt;&gt; g.vertices[i].data;</span><br><span class="line">		g.vertices[i].firstArc = NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; g.arcNum; i++) &#123;</span><br><span class="line"></span><br><span class="line">		int v1, v2;</span><br><span class="line">		cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">		v1 = LocateVNode(g, v1);</span><br><span class="line">		v2 = LocateVNode(g, v2);</span><br><span class="line"></span><br><span class="line">		ArcNode* p1 = new ArcNode;</span><br><span class="line">		p1-&gt;adjvex = v2 + 1;</span><br><span class="line">		p1-&gt;nextArc = g.vertices[v1].firstArc;</span><br><span class="line">		g.vertices[v1].firstArc = p1;</span><br><span class="line">		</span><br><span class="line">		ArcNode* p2 = new ArcNode;</span><br><span class="line">		p2-&gt;adjvex = v1 + 1;</span><br><span class="line">		p2-&gt;nextArc = g.vertices[v2].firstArc;</span><br><span class="line">		g.vertices[v2].firstArc = p2;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line">int CreateDG(ALGraph&amp; g) &#123;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; g.vNum &gt;&gt; g.arcNum;</span><br><span class="line">	g.vertices = new VNode[g.vNum];</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; g.vNum; i++) &#123;</span><br><span class="line">		cin &gt;&gt; g.vertices[i].data;</span><br><span class="line">		g.vertices[i].firstArc = NULL;</span><br><span class="line">		g.vertices[i].inDegree = 0;</span><br><span class="line">		g.vertices[i].outDegree = 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; g.arcNum; i++) &#123;</span><br><span class="line"></span><br><span class="line">		int v1, v2;</span><br><span class="line">		cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">		v1 = LocateVNode(g, v1);</span><br><span class="line">		v2 = LocateVNode(g, v2);</span><br><span class="line">		g.vertices[v2].inDegree++;</span><br><span class="line">		g.vertices[v1].outDegree++;</span><br><span class="line">		ArcNode* p1 = new ArcNode;</span><br><span class="line">		p1-&gt;adjvex = v2 + 1;</span><br><span class="line">		p1-&gt;nextArc = g.vertices[v1].firstArc;</span><br><span class="line">		g.vertices[v1].firstArc = p1;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OutputDegree(ALGraph g) &#123;</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; g.vNum; i++) &#123;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; g.vertices[i].data &lt;&lt; &quot;:&quot;;</span><br><span class="line">		cout &lt;&lt; g.vertices[i].inDegree &lt;&lt; &quot; &quot;;</span><br><span class="line">		cout &lt;&lt; g.vertices[i].outDegree &lt;&lt; &quot; &quot;;</span><br><span class="line">		cout &lt;&lt; g.vertices[i].outDegree + g.vertices[i].inDegree &lt;&lt; &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OutputDGraph(ALGraph g) &#123;</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; g.vNum; i++) &#123;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; g.vertices[i].data &lt;&lt; &quot;:&quot;;</span><br><span class="line">		ArcNode* p = g.vertices[i].firstArc;</span><br><span class="line">		while (p) &#123;</span><br><span class="line">			cout &lt;&lt; p-&gt;adjvex &lt;&lt; &quot; &quot;;</span><br><span class="line">			p = p-&gt;nextArc;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WidthTraverseGraph(ALGraph g) &#123;</span><br><span class="line"></span><br><span class="line">	queue&lt;int&gt; TraverseList;</span><br><span class="line">	int visited[1000];</span><br><span class="line">	memset(visited, 0, sizeof(visited));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;v&quot; &lt;&lt; g.vertices-&gt;data &lt;&lt; &quot; &quot;;</span><br><span class="line">	visited[0] = true;</span><br><span class="line">	TraverseList.push(g.vertices-&gt;data);</span><br><span class="line"></span><br><span class="line">	while (!TraverseList.empty()) &#123;</span><br><span class="line"></span><br><span class="line">		int u = TraverseList.front();</span><br><span class="line">		TraverseList.pop();</span><br><span class="line"></span><br><span class="line">		ArcNode* p = g.vertices[LocateVNode(g,u)].firstArc;</span><br><span class="line"></span><br><span class="line">		while (p != NULL) &#123;</span><br><span class="line">			if (!visited[LocateVNode(g, p-&gt;adjvex)]) &#123;</span><br><span class="line"></span><br><span class="line">				cout &lt;&lt; &quot;v&quot; &lt;&lt; p-&gt;adjvex &lt;&lt; &quot; &quot;;</span><br><span class="line">				visited[LocateVNode(g, p-&gt;adjvex)] = true;</span><br><span class="line">				TraverseList.push(p-&gt;adjvex);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			p = p-&gt;nextArc;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int visited[1000];</span><br><span class="line">void Depth_TG(ALGraph g, int v);</span><br><span class="line"></span><br><span class="line">void DepthTraverseGraph(ALGraph g) &#123;</span><br><span class="line">	</span><br><span class="line">	memset(visited, 0, sizeof(visited));</span><br><span class="line">	for (int i = 0; i &lt; g.vNum; i++) &#123;</span><br><span class="line">		if (visited[i] == 0) &#123;</span><br><span class="line">			Depth_TG(g, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Depth_TG(ALGraph g,int v) &#123;</span><br><span class="line">	cout &lt;&lt; g.vertices[v].data &lt;&lt; &quot; &quot;;</span><br><span class="line">	visited[v] = true;</span><br><span class="line">	ArcNode* p = g.vertices[v].firstArc;</span><br><span class="line">	while (p) &#123;</span><br><span class="line">		int w = LocateVNode(g, p-&gt;adjvex);</span><br><span class="line">		if (!visited[w]) &#123;</span><br><span class="line">			Depth_TG(g, w);</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;nextArc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	ALGraph g;</span><br><span class="line">	CreateDG(g);</span><br><span class="line"></span><br><span class="line">	OutputDegree(g);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构实验3-4</title>
    <url>/2021/11/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C3-4/</url>
    <content><![CDATA[<h2 id="7080"><a href="#7080" class="headerlink" title="7080"></a>7080</h2><p><code>叶子结点个数</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">	char data;</span><br><span class="line">	node* lchild, * rchild;</span><br><span class="line">&#125;Node,*Tree;</span><br><span class="line"></span><br><span class="line">void creattree(Tree&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	char ch;</span><br><span class="line">	cin &gt;&gt; ch;</span><br><span class="line">	if (ch == &#x27;@&#x27;)</span><br><span class="line">	&#123;</span><br><span class="line">		t = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		t = new Node;</span><br><span class="line">		t-&gt;data = ch;</span><br><span class="line">		creattree(t-&gt;lchild);</span><br><span class="line">		creattree(t-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int treeleaf(Tree&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	if (t == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	if (t-&gt;lchild == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		return 1 + treeleaf(t-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		return treeleaf(t-&gt;rchild) + treeleaf(t-&gt;lchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Tree t = new Node;</span><br><span class="line">	creattree(t);</span><br><span class="line">	cout &lt;&lt; treeleaf(t);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="7079"><a href="#7079" class="headerlink" title="7079"></a>7079</h2><p><code>中序遍历</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">	char data;</span><br><span class="line">	node* lchild, * rchild;</span><br><span class="line">&#125;Node,*Tree;</span><br><span class="line"></span><br><span class="line">void creattree(Tree&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	char ch;</span><br><span class="line">	cin &gt;&gt; ch;</span><br><span class="line">	if (ch == &#x27;@&#x27;)</span><br><span class="line">	&#123;</span><br><span class="line">		t = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		t = new Node;</span><br><span class="line">		t-&gt;data = ch;</span><br><span class="line">		creattree(t-&gt;lchild);</span><br><span class="line">		creattree(t-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int treeleaf(Tree&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	if (t == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	if (t-&gt;lchild == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		return 1 + treeleaf(t-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		return treeleaf(t-&gt;rchild) + treeleaf(t-&gt;lchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void MidOutBiTree(Tree t) &#123;</span><br><span class="line">	if (t) &#123;</span><br><span class="line">		MidOutBiTree(t-&gt;lchild);</span><br><span class="line">		cout &lt;&lt; t-&gt;data;</span><br><span class="line">		MidOutBiTree(t-&gt;rchild);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Tree t = new Node;</span><br><span class="line">	creattree(t);</span><br><span class="line">	MidOutBiTree(t);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7077"><a href="#7077" class="headerlink" title="7077"></a>7077</h2><p><code>层次遍历</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">	char data;</span><br><span class="line">	node* lchild, * rchild;</span><br><span class="line">&#125;Node,*Tree;</span><br><span class="line"></span><br><span class="line">void creattree(Tree&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	char ch;</span><br><span class="line">	cin &gt;&gt; ch;</span><br><span class="line">	if (ch == &#x27;@&#x27;)</span><br><span class="line">	&#123;</span><br><span class="line">		t = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		t = new Node;</span><br><span class="line">		t-&gt;data = ch;</span><br><span class="line">		creattree(t-&gt;lchild);</span><br><span class="line">		creattree(t-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void levelorder(Tree t)</span><br><span class="line">&#123;</span><br><span class="line">	queue&lt;Tree&gt; q;</span><br><span class="line">	q.push(t);</span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		Tree temp;</span><br><span class="line">		temp = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		cout &lt;&lt; temp-&gt;data;</span><br><span class="line">		if (temp-&gt;lchild != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			q.push(temp-&gt;lchild);</span><br><span class="line">		&#125;</span><br><span class="line">		if (temp-&gt;rchild != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			q.push(temp-&gt;rchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Tree t = new Node;</span><br><span class="line">	creattree(t);</span><br><span class="line">	levelorder(t);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7076"><a href="#7076" class="headerlink" title="7076"></a>7076</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">	char data;</span><br><span class="line">	node* lchild, * rchild;</span><br><span class="line">&#125;Node,*Tree;</span><br><span class="line"></span><br><span class="line">void creattree(Tree&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	char ch;</span><br><span class="line">	cin &gt;&gt; ch;</span><br><span class="line">	if (ch == &#x27;@&#x27;)</span><br><span class="line">	&#123;</span><br><span class="line">		t = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		t = new Node;</span><br><span class="line">		t-&gt;data = ch;</span><br><span class="line">		creattree(t-&gt;lchild);</span><br><span class="line">		creattree(t-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LeafNum(Tree t, int&amp; num) &#123;</span><br><span class="line">	if (t) &#123;</span><br><span class="line">		if (t-&gt;lchild == NULL &amp;&amp; t-&gt;rchild == NULL) &#123;</span><br><span class="line">			num++;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			LeafNum(t-&gt;lchild, num);</span><br><span class="line">			LeafNum(t-&gt;rchild, num);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int num;</span><br><span class="line">	Tree t = new Node;</span><br><span class="line">	creattree(t);</span><br><span class="line">	LeafNum(t, num);</span><br><span class="line">	cout&lt;&lt;num;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7075"><a href="#7075" class="headerlink" title="7075"></a>7075</h2><p><code>后序遍历</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">	char data;</span><br><span class="line">	node* lchild, * rchild;</span><br><span class="line">&#125;Node,*Tree;</span><br><span class="line"></span><br><span class="line">void creattree(Tree&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	char ch;</span><br><span class="line">	cin &gt;&gt; ch;</span><br><span class="line">	if (ch == &#x27;@&#x27;)</span><br><span class="line">	&#123;</span><br><span class="line">		t = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		t = new Node;</span><br><span class="line">		t-&gt;data = ch;</span><br><span class="line">		creattree(t-&gt;lchild);</span><br><span class="line">		creattree(t-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//后序</span><br><span class="line">void pasorder2(Tree t)</span><br><span class="line">&#123;</span><br><span class="line">	struct</span><br><span class="line">	&#123;</span><br><span class="line">		Tree pp;</span><br><span class="line">		int tag;</span><br><span class="line">	&#125;ss[100];</span><br><span class="line">	int top; Tree p;</span><br><span class="line">	top = 0; p = t;</span><br><span class="line">	while (p || top &gt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		while (p)</span><br><span class="line">		&#123;</span><br><span class="line">			top++;</span><br><span class="line">			ss[top].tag = 0;</span><br><span class="line">			ss[top].pp = p;</span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		if (top &gt; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			if (ss[top].tag == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				ss[top].tag = 1;</span><br><span class="line">				p = ss[top].pp;</span><br><span class="line">				p = p-&gt;rchild;</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				p = ss[top].pp;</span><br><span class="line">				cout &lt;&lt; p-&gt;data;</span><br><span class="line">				top--;</span><br><span class="line">				p = NULL;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Tree t = new Node;</span><br><span class="line">	int num;</span><br><span class="line">	creattree(t);</span><br><span class="line">	pasorder2(t);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7074"><a href="#7074" class="headerlink" title="7074"></a>7074</h2><p><code>树高</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">	char data;</span><br><span class="line">	node* lchild, * rchild;</span><br><span class="line">&#125;Node,*Tree;</span><br><span class="line"></span><br><span class="line">void creattree(Tree&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	char ch;</span><br><span class="line">	cin &gt;&gt; ch;</span><br><span class="line">	if (ch == &#x27;@&#x27;)</span><br><span class="line">	&#123;</span><br><span class="line">		t = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		t = new Node;</span><br><span class="line">		t-&gt;data = ch;</span><br><span class="line">		creattree(t-&gt;lchild);</span><br><span class="line">		creattree(t-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int Depth(Tree t) &#123;</span><br><span class="line">	int m = 0, n = 0;</span><br><span class="line">	if (t == NULL) &#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		m = Depth(t-&gt;lchild);</span><br><span class="line">		n = Depth(t-&gt;rchild);</span><br><span class="line">		if (m &gt; n) &#123;</span><br><span class="line">			return m + 1;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			return n + 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Tree t = new Node;</span><br><span class="line">	int num;</span><br><span class="line">	creattree(t);</span><br><span class="line">	num=Depth(t);</span><br><span class="line">	cout &lt;&lt;num;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构实验2</title>
    <url>/2021/10/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C2/</url>
    <content><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><h2 id="8566"><a href="#8566" class="headerlink" title="8566"></a>8566</h2><p><code>利用栈实现进制转换</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int elementype;</span><br><span class="line"></span><br><span class="line">typedef struct node &#123;</span><br><span class="line">    elementype data;</span><br><span class="line">    struct node* next;</span><br><span class="line">&#125;stacknode, * linkstackptr;</span><br><span class="line"></span><br><span class="line">typedef struct stack &#123;</span><br><span class="line">    linkstackptr top;		//栈顶指针 </span><br><span class="line">    int count;				//计数器 </span><br><span class="line">&#125;Linkstack;</span><br><span class="line"></span><br><span class="line">/* 若栈S为空栈，则返回TRUE，否则返回FALSE */</span><br><span class="line">int stackempty(Linkstack S)</span><br><span class="line">&#123;</span><br><span class="line">    if (S.count == 0)</span><br><span class="line">        return 1;</span><br><span class="line">    else</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool push(Linkstack* S, elementype e)		//入栈操作 </span><br><span class="line">&#123;</span><br><span class="line">    linkstackptr s = (linkstackptr)malloc(sizeof(stacknode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = S-&gt;top;		//把当前的栈顶赋值给新的元素的后继(指针的指向)</span><br><span class="line">    S-&gt;top = s;		//新的节点赋值给栈顶指针（即让新元素成为栈顶元素）</span><br><span class="line">    S-&gt;count++;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int pop(Linkstack* s, elementype* e)		//出栈操作</span><br><span class="line">&#123;</span><br><span class="line">    linkstackptr p;		//临时节点</span><br><span class="line">    if (stackempty(*s))</span><br><span class="line">        return 0;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        *e = s-&gt;top-&gt;data;</span><br><span class="line">        p = s-&gt;top;		//将栈顶指针交给p </span><br><span class="line">        s-&gt;top = s-&gt;top-&gt;next;	//使得栈顶指针下移一位</span><br><span class="line">        free(p);		//因为节点被删除，所以要释放临时节点		</span><br><span class="line">        s-&gt;count--;			//计数器减一个 </span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void visit(elementype p)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d&quot;, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool traversestack(Linkstack s,int m,int n)</span><br><span class="line">&#123;</span><br><span class="line">    linkstackptr p;</span><br><span class="line">    p = s.top;</span><br><span class="line">    printf(&quot;%d(10)=&quot;,m);</span><br><span class="line">    while (p)</span><br><span class="line">    &#123;</span><br><span class="line">        visit(p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;(%d)&quot;,n);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*  构造一个空栈S */</span><br><span class="line">bool InitStack(Linkstack* S)</span><br><span class="line">&#123;</span><br><span class="line">    S-&gt;top = (linkstackptr)malloc(sizeof(stacknode));</span><br><span class="line">    if (!S-&gt;top)</span><br><span class="line">        return false;</span><br><span class="line">    S-&gt;top = NULL;</span><br><span class="line">    S-&gt;count = 0;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 把S置为空栈 */</span><br><span class="line">bool ClearStack(Linkstack* S)</span><br><span class="line">&#123;</span><br><span class="line">    linkstackptr p, q;</span><br><span class="line">    p = S-&gt;top;</span><br><span class="line">    while (p)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        free(q);		//对每一个节点进行释放 </span><br><span class="line">    &#125;</span><br><span class="line">    S-&gt;count = 0;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 返回S的元素个数，即栈的长度 */</span><br><span class="line">int StackLength(Linkstack S)</span><br><span class="line">&#123;</span><br><span class="line">    return S.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR */</span><br><span class="line">int GetTop(Linkstack S, elementype* e)</span><br><span class="line">&#123;</span><br><span class="line">    if (S.top == NULL)</span><br><span class="line">        return 0;</span><br><span class="line">    else</span><br><span class="line">        *e = S.top-&gt;data;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Linkstack s;</span><br><span class="line">    int m, n, a;</span><br><span class="line">    if (InitStack(&amp;s) == true)</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;m,&amp;n);</span><br><span class="line">    int k = m;</span><br><span class="line">    while (m) &#123;</span><br><span class="line">        push(&amp;s, m % n);</span><br><span class="line">        m = m / n;</span><br><span class="line">    &#125;</span><br><span class="line">    traversestack(s,k,n);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h2 id="8569"><a href="#8569" class="headerlink" title="8569"></a>8569</h2><p><code>中缀表达式求值</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt; </span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define MAXSIZE 100</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/*定义顺序栈*/</span><br><span class="line">typedef struct &#123;</span><br><span class="line">	int* base;  //用于栈存储的基地址 </span><br><span class="line">	int* top;  //指向该基地址的栈顶指针 </span><br><span class="line">	int stackSize;  //栈的大小 </span><br><span class="line">&#125;SqStackInt;</span><br><span class="line">/*定义顺序栈*/</span><br><span class="line">typedef struct &#123;</span><br><span class="line">	char* base;  //用于栈存储的基地址 </span><br><span class="line">	char* top;  //指向该基地址的栈顶指针 </span><br><span class="line">	int stackSize;  //栈的大小 </span><br><span class="line">&#125;SqStackChar;</span><br><span class="line">/*初始化*/</span><br><span class="line">int InitStack_Int(SqStackInt&amp; S) &#123;</span><br><span class="line">	S.base = (int*)malloc(MAXSIZE * sizeof(int));  //给基地址分配一个内存空间 </span><br><span class="line">	S.top = S.base;  //将栈顶指针指向这个基地址 </span><br><span class="line">	S.stackSize = MAXSIZE;  //设置栈的大小 </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">int InitStack_Char(SqStackChar&amp; S) &#123;</span><br><span class="line">	S.base = (char*)malloc(MAXSIZE * sizeof(char));  //给基地址分配一个内存空间 </span><br><span class="line">	S.top = S.base;  //将栈顶指针指向这个基地址 </span><br><span class="line">	S.stackSize = MAXSIZE;  //设置栈的大小 </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*进栈*/</span><br><span class="line">int Push_Int(SqStackInt&amp; S, int e) &#123;</span><br><span class="line">	if (S.top - S.base == S.stackSize) return -1;</span><br><span class="line">	*S.top = e;  //将输入的值压入栈中 </span><br><span class="line">	S.top++;  //指针上移一个单位 </span><br><span class="line">	//printf(&quot;操作数%d进S1栈\n&quot;, e);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">int Push_Char(SqStackChar&amp; S, char e) &#123;</span><br><span class="line">	if (S.top - S.base == S.stackSize) return -1;</span><br><span class="line">	*S.top = e;  //将输入的值压入栈中 </span><br><span class="line">	S.top++;  //指针上移一个单位 </span><br><span class="line">	//printf(&quot;操作符%c进S2栈\n&quot;, e);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*出栈*/</span><br><span class="line">int Pop_Int(SqStackInt&amp; S, int&amp; e) &#123;</span><br><span class="line">	if (S.base == S.top) return -1;</span><br><span class="line">	S.top--;  //指针下移一个 </span><br><span class="line">	e = *S.top;  //将当前指针所指的值赋值给e </span><br><span class="line">	//printf(&quot;出栈元素为:%d\n&quot;, e);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">int Pop_Char(SqStackChar&amp; S, char&amp; e) &#123;</span><br><span class="line">	if (S.base == S.top) return -1;</span><br><span class="line"></span><br><span class="line">	S.top--;  //指针下移一个 </span><br><span class="line">	e = *S.top;  //将当前指针所指的值赋值给e </span><br><span class="line">	//printf(&quot;出栈符号为:%c\n&quot;, e);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*获取栈的长度*/</span><br><span class="line">int GetLength_Int(SqStackInt S) &#123;</span><br><span class="line">	return S.top - S.base;</span><br><span class="line">&#125;</span><br><span class="line">int GetLength_Char(SqStackChar S) &#123;</span><br><span class="line">	return S.top - S.base;</span><br><span class="line">&#125;</span><br><span class="line">/*判断栈空*/</span><br><span class="line">int StackEmpty_Int(SqStackInt S) &#123;</span><br><span class="line">	if (S.top == S.base) return 0;  //为空返回 0 </span><br><span class="line">	return 1;  //不为空返回1 </span><br><span class="line">&#125;</span><br><span class="line">int StackEmpty_Char(SqStackChar S) &#123;</span><br><span class="line">	if (S.top == S.base) return 0;  //为空返回 0 </span><br><span class="line">	return 1;  //不为空返回1 </span><br><span class="line">&#125;</span><br><span class="line">/*清空栈*/</span><br><span class="line">int ClearStack_Int(SqStackInt S) &#123;</span><br><span class="line">	if (S.base) //栈不为空 </span><br><span class="line">		S.base = S.top;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">int ClearStack_Char(SqStackChar S) &#123;</span><br><span class="line">	if (S.base) //栈不为空 </span><br><span class="line">		S.base = S.top;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*销毁栈*/</span><br><span class="line">int DestroyStack_Int(SqStackInt&amp; S) &#123;</span><br><span class="line">	if (S.base) &#123;</span><br><span class="line">		free(S.base);</span><br><span class="line">		S.stackSize = 0;</span><br><span class="line">		S.top = S.base = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">int DestroyStack_Char(SqStackChar&amp; S) &#123;</span><br><span class="line">	if (S.base) &#123;</span><br><span class="line">		free(S.base);</span><br><span class="line">		S.stackSize = 0;</span><br><span class="line">		S.top = S.base = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*读取栈顶元素*/</span><br><span class="line">int GetTop_Int(SqStackInt S) &#123;</span><br><span class="line">	return *(S.top - 1);</span><br><span class="line">&#125;</span><br><span class="line">char GetTop_Char(SqStackChar S) &#123;</span><br><span class="line">	return *(S.top - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int isOper(char c) &#123;</span><br><span class="line">	if (c == &#x27;#&#x27; || c == &#x27;+&#x27; || c == &#x27;-&#x27; || c == &#x27;*&#x27; || c == &#x27;/&#x27; || c == &#x27;(&#x27; || c == &#x27;)&#x27;) &#123;</span><br><span class="line">		return 1; //是操作符 </span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		return 0;  //不是操作符 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">* c1:栈顶操作符</span><br><span class="line">* c2:扫描操作符</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">char compare(char op1, char op2)</span><br><span class="line">&#123;</span><br><span class="line">	if (op1 == &#x27;+&#x27; || op1 == &#x27;-&#x27;) &#123;</span><br><span class="line">		if (op2 == &#x27;+&#x27; || op2 == &#x27;-&#x27; || op2 == &#x27;)&#x27; || op2 == &#x27;#&#x27;) &#123;</span><br><span class="line">			return &#x27;&gt;&#x27;;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			return &#x27;&lt;&#x27;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (op1 == &#x27;*&#x27; || op1 == &#x27;/&#x27;) &#123;</span><br><span class="line">		if (op2 == &#x27;(&#x27;) &#123;</span><br><span class="line">			return &#x27;&lt;&#x27;;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			return &#x27;&gt;&#x27;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (op1 == &#x27;(&#x27;) &#123;</span><br><span class="line">		if (op2 == &#x27;+&#x27; || op2 == &#x27;-&#x27; || op2 == &#x27;*&#x27; || op2 == &#x27;/&#x27; || op2 == &#x27;(&#x27;) &#123;</span><br><span class="line">			return &#x27;&lt;&#x27;;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (op2 == &#x27;)&#x27;) &#123;</span><br><span class="line">			return &#x27;=&#x27;;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; &quot;输入有误&quot;;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (op1 == &#x27;)&#x27;) &#123;</span><br><span class="line">		if (op2 == &#x27;+&#x27; || op2 == &#x27;-&#x27; || op2 == &#x27;*&#x27; || op2 == &#x27;/&#x27; || op2 == &#x27;)&#x27; || op2 == &#x27;#&#x27;) &#123;</span><br><span class="line">			return 1;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (op2 == &#x27;(&#x27;) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;输入有误&quot;;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (op1 == &#x27;#&#x27;) &#123;</span><br><span class="line">		if (op2 == &#x27;)&#x27;) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;输入有误&quot;;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (op2 == &#x27;#&#x27;) &#123;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			return &#x27;&lt;&#x27;;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">*从S1栈中弹出两个操作数 a和b</span><br><span class="line">*从S2栈中弹出一个操作符  oper</span><br><span class="line">* 然后两个操作数和一个操作符进行运算</span><br><span class="line">*/</span><br><span class="line">int operate(int a, char oper, int b) &#123;</span><br><span class="line">	if (oper == &#x27;+&#x27;) &#123;</span><br><span class="line">		return a + b;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (oper == &#x27;-&#x27;) &#123;</span><br><span class="line">		return a - b;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (oper == &#x27;*&#x27;) &#123;</span><br><span class="line">		return a * b;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		return a / b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	char arr[100];</span><br><span class="line">	cin &gt;&gt; arr;</span><br><span class="line">	SqStackInt S1;  //用来存储操作数的栈 int 类型 </span><br><span class="line">	SqStackChar S2;</span><br><span class="line">	//初始化两个栈 </span><br><span class="line">	InitStack_Int(S1);</span><br><span class="line">	InitStack_Char(S2);</span><br><span class="line">	//操作符栈 进栈一个 # 号作为结束标志 </span><br><span class="line">	Push_Char(S2, &#x27;#&#x27;);</span><br><span class="line">	int i = 0;  //用于循环遍历 中缀表达式 arr 数组 </span><br><span class="line">	while (arr[i] != &#x27;#&#x27; || GetTop_Char(S2) != &#x27;#&#x27;) &#123;</span><br><span class="line"></span><br><span class="line">		if (!isOper(arr[i])) &#123;  //如果不是操作符 </span><br><span class="line">			int e = arr[i] - &#x27;0&#x27;;</span><br><span class="line">			Push_Int(S1, e);  //进操作数 S1 栈 </span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123; 				//是操作符等待进入 S2 栈 </span><br><span class="line">			char e = arr[i];</span><br><span class="line">			//比较操作符 S2栈  当前栈顶操作符的和当前扫描到的操作符优先级大小 </span><br><span class="line">			switch (compare(GetTop_Char(S2), e)) &#123;</span><br><span class="line">			case &#x27;&lt;&#x27;: &#123;  //栈顶操作符优先级小--&gt; </span><br><span class="line">				Push_Char(S2, e);</span><br><span class="line">				i++;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			case &#x27;=&#x27;: &#123;</span><br><span class="line">				char x;</span><br><span class="line">				Pop_Char(S2, x);</span><br><span class="line">				i++;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			case &#x27;&gt;&#x27;: &#123;</span><br><span class="line">				int a, b; char oper;</span><br><span class="line">				Pop_Int(S1, b); Pop_Int(S1, a);</span><br><span class="line">				Pop_Char(S2, oper);</span><br><span class="line">				int e = operate(a, oper, b);</span><br><span class="line">				Push_Int(S1, e);</span><br><span class="line"></span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d&quot;, GetTop_Int(S1));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8569-1"><a href="#8569-1" class="headerlink" title="8569"></a>8569</h2><p><code>利用队列打印杨辉三角</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using elemtype = int;</span><br><span class="line">const int MAXSIZE = 100;</span><br><span class="line">typedef struct Queue</span><br><span class="line">&#123;</span><br><span class="line">	elemtype* data;</span><br><span class="line">	int front, rear;</span><br><span class="line">&#125;;</span><br><span class="line">bool InitQueue(Queue&amp; Q)</span><br><span class="line">&#123;</span><br><span class="line">	Q.rear = 0;</span><br><span class="line">	Q.front = 0;</span><br><span class="line">	Q.data = new elemtype[MAXSIZE];</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">bool EnQueue(Queue&amp; Q, const elemtype e)</span><br><span class="line">&#123;</span><br><span class="line">	if ((Q.rear + 1) % MAXSIZE == Q.front)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;队满&quot; &lt;&lt; endl;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	Q.data[Q.rear] = e;</span><br><span class="line">	Q.rear = (Q.rear + 1) % MAXSIZE;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">bool DeQueue(Queue&amp; Q, elemtype&amp; e)     //引用不加要出大问题的！！！</span><br><span class="line">&#123;</span><br><span class="line">	if (Q.rear == Q.front)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;队空&quot; &lt;&lt; endl;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	e = Q.data[Q.front];</span><br><span class="line">	Q.front = (Q.front + 1) % MAXSIZE;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">bool IsEmpty(Queue Q)</span><br><span class="line">&#123;</span><br><span class="line">	return Q.rear == Q.front ? true : false;</span><br><span class="line">&#125;</span><br><span class="line">void yanghui(int N)</span><br><span class="line">&#123;</span><br><span class="line">	int i, n, temp, m, add;</span><br><span class="line">	Queue Q;</span><br><span class="line">	InitQueue(Q);</span><br><span class="line">	m = N;</span><br><span class="line">	n = 1;</span><br><span class="line">	while (N &gt;= n)</span><br><span class="line">	&#123;</span><br><span class="line">		for (i = --m; i &gt; 0; i--)</span><br><span class="line">			cout &lt;&lt; &quot;  &quot;;</span><br><span class="line">		cout &lt;&lt; &quot; 1&quot;;</span><br><span class="line">		EnQueue(Q, 1);</span><br><span class="line">		if (n == 1)</span><br><span class="line">		&#123;</span><br><span class="line">			n++;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		DeQueue(Q, temp);</span><br><span class="line">		add = temp;</span><br><span class="line">		for (i = 2; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			DeQueue(Q, temp);</span><br><span class="line">			cout &lt;&lt; &quot;  &quot; &lt;&lt; setw(2) &lt;&lt; add + temp;</span><br><span class="line">			EnQueue(Q, add + temp);</span><br><span class="line">			add = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;   1&quot; &lt;&lt; endl;</span><br><span class="line">		EnQueue(Q, 1);</span><br><span class="line">		n++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	yanghui(n);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构实验8</title>
    <url>/2021/12/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C8/</url>
    <content><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><h2 id="8550"><a href="#8550" class="headerlink" title="8550"></a>8550</h2><p><code>堆排序</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void heapify(int a[],int n,int i)</span><br><span class="line">&#123;</span><br><span class="line">    int largest=i;</span><br><span class="line">    int lson=i*2+1;</span><br><span class="line">    int rson=i*2+2;</span><br><span class="line"></span><br><span class="line">    if(lson&lt;n&amp;&amp;a[largest]&lt;a[lson])</span><br><span class="line">     largest=lson;</span><br><span class="line">    if(rson&lt;n&amp;&amp;a[largest]&lt;a[rson])</span><br><span class="line">      largest=rson;</span><br><span class="line">    if(largest!=i)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(a[largest],a[i]);</span><br><span class="line">        heapify(a,n,largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void heap_sort(int a[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    //建堆</span><br><span class="line">    for(i=n/2-1;i&gt;=0;i--)</span><br><span class="line">      heapify(a,n,i);</span><br><span class="line">    //排序</span><br><span class="line">    for(i=n-1;i&gt;0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(a[i],a[0]);</span><br><span class="line">        heapify(a,i,0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void xier(int *a,int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,inc,key;</span><br><span class="line">    //分组</span><br><span class="line">    for(inc=n/2;inc&gt;0;inc/=2)</span><br><span class="line">    &#123;</span><br><span class="line">        //每组插入排序</span><br><span class="line">        for(i=inc;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            key=a[i];</span><br><span class="line">            for(j=i;j&gt;=inc&amp;&amp;key&lt;a[j-inc];j-=inc)</span><br><span class="line">                a[j]=a[j-inc];</span><br><span class="line">            a[j]=key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[100];</span><br><span class="line">    int b,min;</span><br><span class="line">    int i=0;</span><br><span class="line">    cin&gt;&gt;b;</span><br><span class="line">    while(b!=0)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i++]=b;</span><br><span class="line">        cin&gt;&gt;b;</span><br><span class="line">    &#125;</span><br><span class="line">    /*for(int x=1;x&lt;i;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        int key=a[x];</span><br><span class="line">        int y=x-1;</span><br><span class="line">        while(y&gt;=0&amp;&amp;a[y]&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            a[y+1]=a[y];</span><br><span class="line">            y--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[y+1]=key;</span><br><span class="line">    &#125;*/</span><br><span class="line">    //xier(a,i);</span><br><span class="line">    heap_sort(a,i);</span><br><span class="line">    for(int j=0;j&lt;i;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a[j]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="8549"><a href="#8549" class="headerlink" title="8549"></a>8549</h2><p><code>快速排序</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//low 最左边索引 ，high 最右边索引 ，int 划分位置</span><br><span class="line">int partition(int arr[], int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">    int pivot = arr[high];</span><br><span class="line">    int i = low;</span><br><span class="line"></span><br><span class="line">    for (int j = low; j &lt; high; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        // 比pivot小的，全部换到前面去</span><br><span class="line">        if (arr[j] &lt; pivot)</span><br><span class="line">            swap(arr[j], arr[i++]);</span><br><span class="line">    &#125;</span><br><span class="line">    // 此时，i指向的元素一定大于等于pivot</span><br><span class="line">    swap(arr[high], arr[i]);</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void qsort(int arr[], int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">    if (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = partition(arr, low, high);</span><br><span class="line">        qsort(arr, low, mid - 1);</span><br><span class="line">        qsort(arr, mid + 1, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void quick_sort(int arr[], int len)</span><br><span class="line">&#123;</span><br><span class="line">    qsort(arr, 0, len - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void heapify(int a[],int n,int i)</span><br><span class="line">&#123;</span><br><span class="line">    int largest=i;</span><br><span class="line">    int lson=i*2+1;</span><br><span class="line">    int rson=i*2+2;</span><br><span class="line"></span><br><span class="line">    if(lson&lt;n&amp;&amp;a[largest]&lt;a[lson])</span><br><span class="line">     largest=lson;</span><br><span class="line">    if(rson&lt;n&amp;&amp;a[largest]&lt;a[rson])</span><br><span class="line">      largest=rson;</span><br><span class="line">    if(largest!=i)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(a[largest],a[i]);</span><br><span class="line">        heapify(a,n,largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void heap_sort(int a[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    //建堆</span><br><span class="line">    for(i=n/2-1;i&gt;=0;i--)</span><br><span class="line">      heapify(a,n,i);</span><br><span class="line">    //排序</span><br><span class="line">    for(i=n-1;i&gt;0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(a[i],a[0]);</span><br><span class="line">        heapify(a,i,0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void xier(int *a,int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,inc,key;</span><br><span class="line">    //分组</span><br><span class="line">    for(inc=n/2;inc&gt;0;inc/=2)</span><br><span class="line">    &#123;</span><br><span class="line">        //每组插入排序</span><br><span class="line">        for(i=inc;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            key=a[i];</span><br><span class="line">            for(j=i;j&gt;=inc&amp;&amp;key&lt;a[j-inc];j-=inc)</span><br><span class="line">                a[j]=a[j-inc];</span><br><span class="line">            a[j]=key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[100];</span><br><span class="line">    int b,min;</span><br><span class="line">    int i=0;</span><br><span class="line">    cin&gt;&gt;b;</span><br><span class="line">    while(b!=0)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i++]=b;</span><br><span class="line">        cin&gt;&gt;b;</span><br><span class="line">    &#125;</span><br><span class="line">    /*for(int x=1;x&lt;i;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        int key=a[x];</span><br><span class="line">        int y=x-1;</span><br><span class="line">        while(y&gt;=0&amp;&amp;a[y]&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            a[y+1]=a[y];</span><br><span class="line">            y--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[y+1]=key;</span><br><span class="line">    &#125;*/</span><br><span class="line">    //xier(a,i);</span><br><span class="line">    //heap_sort(a,i);</span><br><span class="line">    quick_sort(a,i);</span><br><span class="line">    for(int j=0;j&lt;i;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a[j]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8547"><a href="#8547" class="headerlink" title="8547"></a>8547</h2><p><code>希尔排序</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void xier(int *a,int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,inc,key;</span><br><span class="line">    //分组</span><br><span class="line">    for(inc=n/2;inc&gt;0;inc/=2)</span><br><span class="line">    &#123;</span><br><span class="line">        //每组插入排序</span><br><span class="line">        for(i=inc;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            key=a[i];</span><br><span class="line">            for(j=i;j&gt;=inc&amp;&amp;key&lt;a[j-inc];j-=inc)</span><br><span class="line">                a[j]=a[j-inc];</span><br><span class="line">            a[j]=key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[100];</span><br><span class="line">    int b,min;</span><br><span class="line">    int i=0;</span><br><span class="line">    cin&gt;&gt;b;</span><br><span class="line">    while(b!=0)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i++]=b;</span><br><span class="line">        cin&gt;&gt;b;</span><br><span class="line">    &#125;</span><br><span class="line">    /*for(int x=1;x&lt;i;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        int key=a[x];</span><br><span class="line">        int y=x-1;</span><br><span class="line">        while(y&gt;=0&amp;&amp;a[y]&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            a[y+1]=a[y];</span><br><span class="line">            y--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[y+1]=key;</span><br><span class="line">    &#125;*/</span><br><span class="line">    xier(a,i);</span><br><span class="line">    for(int j=0;j&lt;i;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a[j]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8545"><a href="#8545" class="headerlink" title="8545"></a>8545</h2><p><code>插入排序</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[100];</span><br><span class="line">    int b,min;</span><br><span class="line">    int i=0;</span><br><span class="line">    cin&gt;&gt;b;</span><br><span class="line">    while(b!=0)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i++]=b;</span><br><span class="line">        cin&gt;&gt;b;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int x=1;x&lt;i;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        int key=a[x];</span><br><span class="line">        int y=x-1;</span><br><span class="line">        while(y&gt;=0&amp;&amp;a[y]&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            a[y+1]=a[y];</span><br><span class="line">            y--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[y+1]=key;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int j=0;j&lt;i;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a[j]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>新的征程</title>
    <url>/2021/07/25/%E6%96%B0%E7%9A%84%E5%BE%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="新的征程"><a href="#新的征程" class="headerlink" title="新的征程"></a>新的征程</h1><h2 id="第一篇文章哦-试验"><a href="#第一篇文章哦-试验" class="headerlink" title="第一篇文章哦-试验"></a>第一篇文章哦-试验</h2><ul>
<li>列表1<br>  <a href="https://www.bilibili.com/">哔哩哔哩</a></li>
<li>列表2<br>  无</li>
</ul>
<hr>
<p><em>斜着的字哦</em><br><strong>加粗字体</strong><br><code>&lt;html&gt;&lt;/html&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hello world&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用xxx</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>胡思乱想</title>
    <url>/2022/11/01/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/</url>
    <content><![CDATA[<p><strong>感谢每一次的陪伴，相约东林的傍晚</strong><br>2022年11月1日，农历十月初八，一个重要的生日（不写你也一定能想起来！）。<br>最近想了很多，因为我感觉周围人都很不真实，其实也不算，就是普通朋友罢了，我现在特别理解什么叫“知音难觅”，在成长的道路上碰见一两个交心的朋友是难得中的难得啊，尤其是大学，大家交际圈都很广，每个人都一样，你也没什么特殊的罢了。<br>大学时光也只剩一半的四分之三了，好好珍惜这四年，不要死盯着某个人某一件事，就像化学老师（你一定知道是谁！）说的“边走边爱”，真的是很对，加油吧！emmm祝你生日快乐吧！也愿你历经千帆，归来仍少年！不忘初心！</p>
]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>超</title>
    <url>/2021/11/25/%E8%B6%85/</url>
    <content><![CDATA[<h1 id="人能干的咱就干，人干不了的咱想法干。"><a href="#人能干的咱就干，人干不了的咱想法干。" class="headerlink" title="人能干的咱就干，人干不了的咱想法干。"></a>人能干的咱就干，人干不了的咱想法干。</h1>]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>无聊之谈</title>
    <url>/2021/11/03/%E6%97%A0%E8%81%8A%E4%B9%8B%E8%B0%88/</url>
    <content><![CDATA[<h1 id="毛遂自荐"><a href="#毛遂自荐" class="headerlink" title="毛遂自荐"></a>毛遂自荐</h1><p>赵文博是个花心的人，尽管他智力超群，<br>他有一双普通的眼睛，对于晶莹剔透的情有独钟，<br>他深知孔夫子的教诲：见贤思齐焉，见不贤而内自省也。<br>所以他一定可以一骑绝尘。</p>
]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>棋盘覆盖问题</title>
    <url>/2022/04/01/%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="天下之至拙，能胜天下之至巧"><a href="#天下之至拙，能胜天下之至巧" class="headerlink" title="天下之至拙，能胜天下之至巧"></a>天下之至拙，能胜天下之至巧</h2><p>简介：<br>在一个2^k×2^k 个方格组成的棋盘中，恰有一个方格与其它方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。<br><em><strong>代码请点击“阅读全文”</strong></em></p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int title = 1;</span><br><span class="line">int board[100][100];</span><br><span class="line">void ChessBoard(int tr, int tc, int dr, int dc, int size)</span><br><span class="line">&#123;	</span><br><span class="line">	if (size == 1) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	int t = title++;</span><br><span class="line">	int s = size / 2;</span><br><span class="line">	//左上角</span><br><span class="line">	if (dr &lt; tr + s &amp;&amp; dc &lt; tc + s) &#123;</span><br><span class="line">		ChessBoard(tr, tc, dr, dc, s);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		board[tr + s - 1][tc + s - 1] = t;</span><br><span class="line">		ChessBoard(tr, tc, tr + s - 1, tc + s - 1, s);</span><br><span class="line">	&#125;</span><br><span class="line">	//右上角</span><br><span class="line">	if (dr &lt; tr + s &amp;&amp; dc &gt;= tc + s) &#123;</span><br><span class="line">		ChessBoard(tr, tc + s, dr, dc, s);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		board[tr + s - 1][tc + s] = t;</span><br><span class="line">		ChessBoard(tr, tc + s, tr + s - 1, tc + s, s);</span><br><span class="line">	&#125;</span><br><span class="line">	//左下角</span><br><span class="line">	if (dr &gt;= tr + s &amp;&amp; dc &lt; tc + s) &#123;</span><br><span class="line">		ChessBoard(tr+s, tc , dr, dc, s);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		board[tr + s][tc + s-1] = t;</span><br><span class="line">		ChessBoard(tr+s, tc , tr + s , tc + s-1, s);</span><br><span class="line">	&#125;</span><br><span class="line">	//右下角</span><br><span class="line">	if (dr &gt;= tr + s &amp;&amp; dc &gt;= tc + s) &#123;</span><br><span class="line">		ChessBoard(tr + s, tc+s, dr, dc, s);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		board[tr + s][tc + s ] = t;</span><br><span class="line">		ChessBoard(tr + s, tc+s, tr + s, tc + s, s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int tr, tc,dr,dc,size;//tr,tc 分别是棋盘左上角的行列坐标，dr,dc 分别是特殊方格行列坐标，size 是棋盘的行数或者列数</span><br><span class="line">	cin &gt;&gt;size &gt;&gt;dr &gt;&gt; dc;</span><br><span class="line">	ChessBoard(1, 1, dr, dc, size);</span><br><span class="line">	for (int i = 1; i &lt;= size; i++) &#123;</span><br><span class="line">		int j = 1;</span><br><span class="line">		for (; j &lt;= size-1; j++) &#123;</span><br><span class="line">			cout &lt;&lt;setw(2)&lt;&lt; board[i][j]&lt;&lt;&quot; &quot;;//setw(2)起到限制输出宽度的作用</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt;setw(2)&lt;&lt; board[i][j];</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【补档】操作系统之小和尚老和尚喝水问题</title>
    <url>/2022/11/15/%E3%80%90%E8%A1%A5%E6%A1%A3%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%B0%8F%E5%92%8C%E5%B0%9A%E8%80%81%E5%92%8C%E5%B0%9A%E5%96%9D%E6%B0%B4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最近发现一首宝藏歌曲<a href="https://www.bilibili.com/video/BV1Ur4y1v7g5/?spm_id_from=trigger_reload&vd_source=f78b53406940acb31cf9f8654e6a7ee6">《忧愁》</a>，闽南语的，很好听。</p>
<p>问题描述：某寺庙，有小和尚和老和尚若干。庙内有一口水缸，由小和尚提水入缸，供老和尚饮用。水缸可容纳30桶水，每次入水取水仅为1桶，不可同时进行。水取自同一井中，水井径窄，每次只能容纳一个水桶取水。</p>
<p>求：设水桶个数为5个，试用信号量和ws操作给出老和尚和小和尚的活动。</p>
<p>解题思路：这个问题与生产者消费者问题类似，只是需要设置两个缓冲池分别表示水桶和水缸，这就需要分别给两个缓冲池设置同步信号量了，互斥信号量由于开闭操作配套使用，故全程序只用一个即可。总的来说，三个线程，老和尚和小和尚（取水和倒水）；两个缓冲池，水桶和水缸；五个信号量。然后让小和尚互斥的执行取水和倒水操作，老和尚互斥执行的喝水操作即可。<br><em><strong>代码请点击“阅读全文”</strong></em></p>
<span id="more"></span>
<p>完整代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;semaphore.h&gt;</span><br><span class="line">#define  PRODUCER_NUM 5//小和尚数目</span><br><span class="line">#define  CONSUMER_NUM 5//老和尚数目</span><br><span class="line">#define  POOL_SIZE 30//水缸大小</span><br><span class="line">#define  POOL_SIZE_1 5//水桶数量</span><br><span class="line"></span><br><span class="line">int pool[POOL_SIZE];//水缸</span><br><span class="line">int head=0;//缓冲池读取指针</span><br><span class="line">int rear=0;//缓冲池写入指针</span><br><span class="line">sem_t room_sem;//同步信号信号量，表示缓冲区有可用间</span><br><span class="line">sem_t product_sem;//同步信号量，表示缓冲区有可用品</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int pool_1[POOL_SIZE_1];//水桶</span><br><span class="line">int head_1=0;//缓冲池读取指针</span><br><span class="line">int rear_1=0;//缓冲池写入指针</span><br><span class="line">sem_t room_sem_1;//同步信号信号量，表示缓冲区有可用间</span><br><span class="line">sem_t product_sem_1;//同步信号量，表示缓冲区有可用品</span><br><span class="line"></span><br><span class="line">pthread_mutex_t mutex;//互斥信号量</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void* producer_fun(void* arg)//小和尚倒水（水桶和水缸）</span><br><span class="line">&#123;</span><br><span class="line">	while (1)</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(rand() % 10 + 1);</span><br><span class="line">		sem_wait(&amp;room_sem);</span><br><span class="line">		sem_wait(&amp;product_sem_1);</span><br><span class="line">		pthread_mutex_lock(&amp;mutex);</span><br><span class="line">		//生产者往缓冲池中写入数据（小和尚倒水入缸）</span><br><span class="line">		pool[rear] = 1;</span><br><span class="line">		rear = (rear + 1) % POOL_SIZE;</span><br><span class="line">		head_1 = (head_1 + 1) % POOL_SIZE_1;</span><br><span class="line">		printf(&quot;producer %d  write water to pool\n&quot;, (int)arg);</span><br><span class="line">		printf(&quot;pool size is %d\n&quot;, (rear - head + POOL_SIZE) % POOL_SIZE);</span><br><span class="line"></span><br><span class="line">		printf(&quot;小和尚%d倒水进水缸\n&quot;, (int)arg);</span><br><span class="line">		printf(&quot;水缸有%d桶水\n&quot;, (rear - head + POOL_SIZE) % POOL_SIZE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">		sem_post(&amp;product_sem);</span><br><span class="line">		sem_post(&amp;room_sem_1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void* producer_fun_1(void* arg)//小和尚取水到水桶</span><br><span class="line">&#123;</span><br><span class="line">	while (1)</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(rand() % 10 + 1);</span><br><span class="line">		sem_wait(&amp;room_sem_1);</span><br><span class="line">		pthread_mutex_lock(&amp;mutex);</span><br><span class="line">		//（小和尚从水井取水）</span><br><span class="line">		pool_1[rear_1] = 1;</span><br><span class="line">		rear_1 = (rear_1 + 1) % POOL_SIZE_1;</span><br><span class="line">		printf(&quot;producer %d  get water from pool_1\n&quot;, (int)arg);</span><br><span class="line">		printf(&quot;pool_1 size is %d\n&quot;, (rear_1 - head_1 + POOL_SIZE_1) % POOL_SIZE_1);</span><br><span class="line"></span><br><span class="line">		printf(&quot;小和尚%d从水井打水一桶\n&quot;, (int)arg);</span><br><span class="line">		printf(&quot;现在有%d桶水没倒进水缸\n&quot;, (rear_1 - head_1 + POOL_SIZE_1) % POOL_SIZE_1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">		sem_post(&amp;product_sem_1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void* consumer_fun(void* arg)//老和尚喝水从水缸</span><br><span class="line">&#123;</span><br><span class="line">	while (1)</span><br><span class="line">	&#123;</span><br><span class="line">		int data;</span><br><span class="line">		sleep(rand() % 10 + 1);</span><br><span class="line">		sem_wait(&amp;product_sem);</span><br><span class="line">		pthread_mutex_lock(&amp;mutex);</span><br><span class="line">		//消费者从缓冲池读取数据</span><br><span class="line">		data = pool[head];</span><br><span class="line">		head = (head + 1) % POOL_SIZE;</span><br><span class="line">		printf(&quot;consumer %d drink water from pool\n&quot;, (int)arg);</span><br><span class="line">		printf(&quot;pool size is %d\n&quot;, (rear - head + POOL_SIZE) % POOL_SIZE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		printf(&quot;老和尚%d从水缸喝水\n&quot;, (int)arg);</span><br><span class="line">		printf(&quot;水缸有%d桶水\n&quot;, (rear - head + POOL_SIZE) % POOL_SIZE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">		sem_post(&amp;room_sem);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	srand((int)time(0));</span><br><span class="line"></span><br><span class="line">	pthread_t producer_id[PRODUCER_NUM];//小和尚</span><br><span class="line">	pthread_t consumer_id[CONSUMER_NUM];//老和尚</span><br><span class="line"></span><br><span class="line">	pthread_mutex_init(&amp;mutex, NULL);//初始化互斥量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	int ret = sem_init(&amp;room_sem, 0, POOL_SIZE - 1);//初始化信号量room_sem（水缸）为缓冲池大小</span><br><span class="line">	if (ret != 0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;sem_init error&quot;);</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	ret = sem_init(&amp;product_sem, 0, 0);//初始化信号量product_sem（水缸）为0，开始时缓冲池中没有数据</span><br><span class="line">	if (ret != 0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;sem_init error&quot;);</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	int ret_1 = sem_init(&amp;room_sem_1, 0, POOL_SIZE_1 - 1);//初始化信号量room_sem（水桶）为缓冲池大小</span><br><span class="line">	if (ret_1 != 0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;sem_init error&quot;);</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	ret_1 = sem_init(&amp;product_sem_1, 0, 0);//初始化信号量product_sem（水桶）为0，开始时缓冲池中没有数据</span><br><span class="line">	if (ret_1 != 0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;sem_init error&quot;);</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	int i;</span><br><span class="line">	for (i = 0; i &lt; PRODUCER_NUM; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		//创建小和尚倒水线程</span><br><span class="line">		ret = pthread_create(&amp;producer_id[i], NULL, producer_fun, (void*)i);</span><br><span class="line">		if (ret != 0)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;producer_id error&quot;);</span><br><span class="line">			exit(0);</span><br><span class="line">		&#125;</span><br><span class="line">		//创建老和尚取水线程</span><br><span class="line">		ret = pthread_create(&amp;consumer_id[i], NULL, consumer_fun, (void*)i);</span><br><span class="line">		if (ret != 0)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;consumer_id error&quot;);</span><br><span class="line">			exit(0);</span><br><span class="line">		&#125;</span><br><span class="line">		//创建小和尚取水线程</span><br><span class="line">		ret_1=pthread_create(&amp;producer_id[i],NULL,producer_fun_1,(void*)i);</span><br><span class="line">		if(ret_1!=0)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;producer_id error&quot;);</span><br><span class="line">			exit(0);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for (i = 0; i &lt; PRODUCER_NUM; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_join(producer_id[i], NULL);</span><br><span class="line">		pthread_join(consumer_id[i], NULL);</span><br><span class="line">	&#125;</span><br><span class="line">	exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>问题汇总</title>
    <url>/2023/05/09/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>closing inbound before receiving peer’s close_notify<br>java连接数据库时发生以上错误提示<br>原因：数据库版本问题<br>解决：只需在数据库连接URL加useSSL=false即可。<br>参考链接：<a href="http://www.manongjc.com/detail/19-ejouaquyubmwspn.html">http://www.manongjc.com/detail/19-ejouaquyubmwspn.html</a></p>
]]></content>
      <categories>
        <category>JAVA报错</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
</search>
